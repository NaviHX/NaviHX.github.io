<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title></title>
    <link href="https://refrigerator.navihx.top/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://refrigerator.navihx.top"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-09-19T00:00:00+00:00</updated>
    <id>https://refrigerator.navihx.top/atom.xml</id>
    <entry xml:lang="en">
        <title>Single Number</title>
        <published>2024-09-19T00:00:00+00:00</published>
        <updated>2024-09-19T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/single-number/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/single-number/</id>
        
        <content type="html">&lt;h1 id=&quot;zhi-chu-xian-yi-ci-de-shu-zi&quot;&gt;只出现一次的数字&lt;&#x2F;h1&gt;
&lt;p&gt;给你一个非空整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;&#x2F;p&gt;
&lt;p&gt;必须使用线性时间，常量空间的算法。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;&#x2F;h2&gt;
&lt;p&gt;根据异或的性质，将所有元素异或后的结果为只出现一次的元素，因为&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;x ^ x == 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;且异或满足交换律与结合律，只需要将相同的元素移动到相同位置即可证明。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;single_number&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(!nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;    nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;| a ^ b)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;chu-xian-liang-ci-de-shu-zi&quot;&gt;出现两次的数字&lt;&#x2F;h1&gt;
&lt;p&gt;下面来考虑上面问题的一个变式。&lt;&#x2F;p&gt;
&lt;p&gt;给你一个非空整数数组 nums 其长度为 n + 1 ，只会出现 0..n 的数字，除了某个元素出现两次以外，其余每个元素均只出现一次。找出那个只出现了两次的元素。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution-1&quot;&gt;Solution&lt;&#x2F;h2&gt;
&lt;p&gt;这个问题拥有更强的条件：只会出现 0..n 的数字。&lt;&#x2F;p&gt;
&lt;p&gt;因为我们知道数组中出现的元素范围，我们只需要将 nums 所有元素的异或再与 0..n 的所有数异或一遍。这样可以使得原本出现两次的元素现在出现了三次（异或结果为本身），原本出现一次的元素出现了两次（异或结果为 0 ）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;double_number&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; n = nums.len - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copied&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..n as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;| a ^ b)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;sneaky-numbers&quot;&gt;Sneaky Numbers&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;the-two-sneaky-numbers-of-digitville&#x2F;description&#x2F;&quot;&gt;原题目&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一个数字列表 nums，其中包含从 0 到 n - 1 的整数。每个数字本应只出现一次，然而，有两个顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。请你找出这两个顽皮的数字。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution-2&quot;&gt;Solution&lt;&#x2F;h2&gt;
&lt;p&gt;相比于前一个题目，这一个题目中出现了两次的元素有两个。也就是说假设出现两次的元素分别为 a, b ，参考上一个题目的方法，所有元素的异或结果应为 a ^ b 。&lt;&#x2F;p&gt;
&lt;p&gt;因为这 &lt;code&gt;a != b&lt;&#x2F;code&gt; ，所以 &lt;code&gt;a ^ b&lt;&#x2F;code&gt; 的结果中必定至少有一个 &lt;code&gt;1&lt;&#x2F;code&gt; bit ，假设只保留其中最低位的 &lt;code&gt;1&lt;&#x2F;code&gt; bit 的数为 lowbit 。我们可以将列表中的所有元素分为两类：lowbit 处为 1 的数以及 lowbit 处为 0 的数。分别将两类数异或的结果就是所求的元素。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sneaky_numbers&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; n = nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sum = nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copied&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..n as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;| a ^ b);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; lowbit = sum &amp;amp; -sum;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; ans = vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; num in nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copied&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..n as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; num &amp;amp; lowbit == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;        ans[id] ^= num;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ans
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Welcome to the Food Factory</title>
        <published>2024-04-19T00:00:00+00:00</published>
        <updated>2024-04-19T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/welcome-to-the-food-factory/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/welcome-to-the-food-factory/</id>
        
        <content type="html">&lt;h1 id=&quot;welcome-to-the-food-factory&quot;&gt;Welcome to the Food Factory!&lt;&#x2F;h1&gt;
&lt;p&gt;这是一篇介绍 &lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95&quot;&gt;工厂模式&lt;&#x2F;a&gt; 的短文。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yuan-shi-ji-qi&quot;&gt;原始机器&lt;&#x2F;h2&gt;
&lt;p&gt;假如你是一位机械工程师，你开发了一款机器，它可以自动使用原材料生产食物。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; water = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;boil&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dish = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;make_dish_with_water&lt;&#x2F;span&gt;&lt;span&gt;(input, water);
&lt;&#x2F;span&gt;&lt;span&gt;    dish
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你觉得这样很不错，因为你可以使用这一台机器构造流水线，完成每天的工厂生产任务。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; products = vec![];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; input = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ingredients&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_product = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(input);
&lt;&#x2F;span&gt;&lt;span&gt;    products.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(new_product);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ding-dan-xu-qiu-gai-bian&quot;&gt;订单需求改变&lt;&#x2F;h2&gt;
&lt;p&gt;你突然接到了一个新订单，它不再需要用水煮的食物，而是用火烤的。你的第一反应是改进原本的机器。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dish = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;roast&lt;&#x2F;span&gt;&lt;span&gt;(input);
&lt;&#x2F;span&gt;&lt;span&gt;    dish
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; products = vec![];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; input = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ingredients&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_product = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(input);
&lt;&#x2F;span&gt;&lt;span&gt;    products.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(new_product);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;实际上，这是一个很不明智的做法：如果你还需要生产原始的订单，你还需要把机器再改回去。所以，一个更好的方法是，在保留原有的机器基础上，重新设计一台新机器。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; water = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;boil&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dish = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;make_dish_with_water&lt;&#x2F;span&gt;&lt;span&gt;(input, water);
&lt;&#x2F;span&gt;&lt;span&gt;    dish
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;roast_machine&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dish = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;roast&lt;&#x2F;span&gt;&lt;span&gt;(input);
&lt;&#x2F;span&gt;&lt;span&gt;    dish
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样的话，你就能根据订单类型来决定生产哪种食品了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;Order{
&lt;&#x2F;span&gt;&lt;span&gt;    Original,
&lt;&#x2F;span&gt;&lt;span&gt;    Roast,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;assembly_line&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;order&lt;&#x2F;span&gt;&lt;span&gt;: Order, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;amount&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Vec&amp;lt;Dish&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; products = vec![];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..amount {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;Order::*;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; input = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ingredients&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_product = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; order {
&lt;&#x2F;span&gt;&lt;span&gt;            Original =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(input),
&lt;&#x2F;span&gt;&lt;span&gt;            Roast =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;roast_machine&lt;&#x2F;span&gt;&lt;span&gt;(input),
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        products.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(new_product);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    products
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然而，随着你业务的增长，你的流水线里很可能有非常多的机器种类。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;assembly_line&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;order&lt;&#x2F;span&gt;&lt;span&gt;: Order, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;amount&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Vec&amp;lt;Dish&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_product = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; order {
&lt;&#x2F;span&gt;&lt;span&gt;        Original =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;        Roast =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Oh my god. Too many machines!
&lt;&#x2F;span&gt;&lt;span&gt;        Fry =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个时候，你的流水线构造（或者说你的代码）将会变得十分冗余，每次添加新的订单种类，总是需要设计新的机器。有没有办法作出改变呢？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zuo-shi-yao-ni-lai-jue-ding&quot;&gt;做什么，你来决定&lt;&#x2F;h2&gt;
&lt;p&gt;在之前的设计中，流水线只能生产已经设计好的产品（已经设计了机器的商品）。而实际上，客户总是能提出新的订单需求，作为工程师，每次设计一个新的机器是十分费神的。为了节约精力，我们需要让客户自己决定生产的流程。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;Order {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;produce&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;客户需要通过写明制作流程，告诉我们应该如何制作。我们只需要制造新的满足流程的机器就好了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;OriginalOrder;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Order &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;OriginalOrder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;produce&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;original_machine&lt;&#x2F;span&gt;&lt;span&gt;(input) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 客户说，使用本来的设计就行了。
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;RoastOrder;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Order &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;RoastOrder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;produce&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;roast_machine&lt;&#x2F;span&gt;&lt;span&gt;(input) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 这个订单需要火烤。
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;FryOrder;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Order &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;FryOrder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;produce&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Ingredients) -&amp;gt; Dish {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fry_order&lt;&#x2F;span&gt;&lt;span&gt;(input) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 油炸也是可以完成的。
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当需要生产时，客户把订单交给我们，我们按订单上写明的流程生产就行了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;assembly_line&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;order&lt;&#x2F;span&gt;&lt;span&gt;: impl Order, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;amount&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Vec&amp;lt;Dish&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; products = vec![];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..amount {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; input = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_ingredients&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_product = order.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;produce&lt;&#x2F;span&gt;&lt;span&gt;(input);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        products.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(new_product);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    products
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;xian-zai-ni-yong-you-liao-gong-han-mo-shi&quot;&gt;现在你拥有了工厂模式&lt;&#x2F;h2&gt;
&lt;p&gt;如果我们把这层食品工厂的皮扒掉，工厂其实是一个这样的东西。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Factory :: Input -&amp;gt; Output
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;它获取一个输入，返回一个输出。这里的输出既可以是某一个具体的类型，也可以是满足一个特征的类型集合，我们根据输入的不同产生不同的输出。&lt;&#x2F;p&gt;
&lt;p&gt;工厂提供了创建一个值的流程的抽象，将创建流程的控制反转给了输入。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Produce :: input -&amp;gt; Factory -&amp;gt; output
&lt;&#x2F;span&gt;&lt;span&gt;Produce input factory = factory input -- 根据不同的工厂决定如何输出
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Range Bitwise-And</title>
        <published>2024-04-01T00:00:00+00:00</published>
        <updated>2024-04-01T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/range-bitwise-and/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/range-bitwise-and/</id>
        
        <content type="html">&lt;h1 id=&quot;shu-zi-fan-wei-an-wei-yu&quot;&gt;数字范围按位与&lt;&#x2F;h1&gt;
&lt;p&gt;给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 &lt;em&gt;按位与&lt;&#x2F;em&gt; 的结果（包含 left 、right 端点）。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;&#x2F;h1&gt;
&lt;p&gt;注意到按位与的特性：只要参与按位与的所有数中，有一个数在某一位为零，那么结果的这一位肯定为零。&lt;&#x2F;p&gt;
&lt;p&gt;同时我们可以发现在连续出现的数中，第 i 位的数是 0 与 1 交替出现的，交替出现的周期为 2^(i+1) ，也就是说，最长会连续出现 2^i 个 1 。因此我们只需要知道两个端点处第 i 位是否为 1，同时两个端点的距离 dis 是否超过半个周期，就能判断结果中第 i 位是否为一。结果的第 i 位可以通过下面的公式计算：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;mask i = shiftL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt; i
&lt;&#x2F;span&gt;&lt;span&gt;ans left right i = (left .&amp;amp;. mask i) .&amp;amp;. (right .&amp;amp;. mask i) .&amp;amp;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; (right - left) &amp;lt; mask i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xffffffff &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对应的 Rust 代码是&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;range_bitwise_and&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;left&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;right&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dis = right - left;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; ans = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;31 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; m = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; i;
&lt;&#x2F;span&gt;&lt;span&gt;        ans |= left &amp;amp; right &amp;amp; m &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; dis &amp;lt; m { !&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ans
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;观察第二个式子我们可以发现， (dis\ &amp;lt;\ mask) 是关于 i 单调递增的，即存在一个 a 使得 i &amp;gt;= a, dis &amp;gt;= mask 且 i &amp;lt; a, dis &amp;lt; mask 。那么我们只需要找出最小的满足条件的 i ，就可以知道该位以及更高的位的掩码都是 1 。&lt;&#x2F;p&gt;
&lt;p&gt;现在我们需要找到一个方法求到每一位的掩码组合在一起的掩码，这样就可以同时计算所有位了。方法是很简单的：将 dis 最高的 1 以下的位全部置为 1 ，然后按位取反。这样就可以保证，只保留最低的 1 ，掩码也是大于 dis 的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;range_bitwise_and&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;left&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;right&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dis = right - left;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; m = dis;
&lt;&#x2F;span&gt;&lt;span&gt;    m = m | (m &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    m = m | (m &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    m = m | (m &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    m = m | (m &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    m = m | (m &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    m = !m;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    left &amp;amp; right &amp;amp; m
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Prefix-Sum of Prefix-Sum of Ones</title>
        <published>2024-03-17T00:00:00+00:00</published>
        <updated>2024-03-17T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/prefix-sum-of-prefix-sum/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/prefix-sum-of-prefix-sum/</id>
        
        <content type="html">&lt;h1 id=&quot;prefix-sum-of-prefix-sum-of-ones&quot;&gt;Prefix-Sum of Prefix-Sum of Ones&lt;&#x2F;h1&gt;
&lt;p&gt;给定两个给定数组 A 和 B ，从这两个数组各取一个元素可以组成一个坐标 (x, y) 。现以这种方式获得两个坐标 P1 (x1, y1) 和 P2 (x2, y2) ，求有多少种取法，使得 x2 &amp;lt;= x1 ，y2 &amp;lt;= y1 。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;&#x2F;h1&gt;
&lt;p&gt;如果我们分别将两个数组从小到大排序，并分别以 i 和 j 来索引两个数组，那么假设我们选定了 i 和 j 索引到的元素组成坐标，很显然同样使用 i ，j 索引的元素组成的坐标满足条件。同时我们知道，i - 1 和 j - 1 索引到的元素一定比 i 和 j 索引的元素小，所以我们可以这样计算对于 i 和 j 满足条件的数量：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- f 计算对于 i j 满足条件的值
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 很显然，i j 本身一定满足条件
&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 对于边界，我们只能累加它的左边或者下面
&lt;&#x2F;span&gt;&lt;span&gt;f i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (f (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 注意，这里需要减去重复计算的部分
&lt;&#x2F;span&gt;&lt;span&gt;f i j = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (f (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j) + (f i (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) - (f (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意到这其实是一个二维前缀和，每一个位置的元素都是 1 。现在我们对这些式子进行化简。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 第一个式子不需要化简
&lt;&#x2F;span&gt;&lt;span&gt;f&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 对于边界，实际上就是累加 1
&lt;&#x2F;span&gt;&lt;span&gt;f&amp;#39; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;f&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j = j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 这里需要一些技巧
&lt;&#x2F;span&gt;&lt;span&gt;f&amp;#39; i j = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (f (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j) + (f i (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) - (f (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 注意到 i j 处的前缀和实际上是上一行的前缀和，加上这一行的和
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 本行的和为 i + 1
&lt;&#x2F;span&gt;&lt;span&gt;= (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) + (f&amp;#39; (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 在 j 不变的情况下，每一行的和实际上都是 i + 1
&lt;&#x2F;span&gt;&lt;span&gt;= (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;化简得到的结果为 &lt;code&gt;f i j = (i + 1) * (j + 1)&lt;&#x2F;code&gt; ，对于边界情况同样满足。接下来我们需要进行下一步：计算对于 i j ，求所有 i&#x27; &amp;lt;= i , j&#x27; &amp;lt;= j 的所有满足条件的值之和。首先我们给出前缀和的一般形式：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- func 是计算 i j 处的值的函数
&lt;&#x2F;span&gt;&lt;span&gt;presum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0&lt;&#x2F;span&gt;&lt;span&gt; func = func &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0
&lt;&#x2F;span&gt;&lt;span&gt;presum i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; func = (func i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) + (presum (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;presum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j func = (func &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j) + (presum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;presum i j func = (func i j) + (presum (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j) + (presum i (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) - (presum (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;假设 g 为求取这个值的函数。我们对一般形式进行替换：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0 &lt;&#x2F;span&gt;&lt;span&gt;= f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0
&lt;&#x2F;span&gt;&lt;span&gt;g i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= (f i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) + (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j = (f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j) + (g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;g i j = (f i j) + (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j) + (g i (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) - (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在把 f 的值代入进去：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 0 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;g i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j = j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;g i j = (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) + (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j) + (g i (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) - (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) (j - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;边界的两种情况是很容易化简的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 应用等差数列求和公式
&lt;&#x2F;span&gt;&lt;span&gt;g i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; j = (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最后一种情况我们应用之前使用的技巧：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 注意到 i j 处的前缀和实际上是上一行的前缀和，加上这一行的和
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 本行的和就是 (g 0 j) * (i + 1)
&lt;&#x2F;span&gt;&lt;span&gt;g i j = ((j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) + (g (i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) j)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 在 j 不变的情况下，每一行的和都是 (g 0 j) * i
&lt;&#x2F;span&gt;&lt;span&gt;= ((i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * ((j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;= (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * (j + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所以，我们只需要知道两个数组的长度，就能计算出满足条件的个数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;prefix_sum_of_prefix_sum_of_ones m n = (m + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) * m * (n + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) * n &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Subseq Sum Permutations</title>
        <published>2024-03-09T00:00:00+00:00</published>
        <updated>2024-03-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/subseq-sum-perm/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/subseq-sum-perm/</id>
        
        <content type="html">&lt;h1 id=&quot;qiu-zi-xu-lie-de-di-k-xiao-he&quot;&gt;求子序列的第 k 小和&lt;&#x2F;h1&gt;
&lt;p&gt;给定一个正整数数组 &lt;code&gt;nums&lt;&#x2F;code&gt; 和 一个非负数 &lt;code&gt;k&lt;&#x2F;code&gt; ，求出第 k 小的子序列和。&lt;&#x2F;p&gt;
&lt;p&gt;相同的不同子序列之和视为不同的和。同时空子序列的和记为 0 。例如对于数组 &lt;code&gt;[1, 2, 3]&lt;&#x2F;code&gt; ，它的子序列和的从小到大的排列是&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;text&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-text &quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    0 = [],
&lt;&#x2F;span&gt;&lt;span&gt;    1 = [1],
&lt;&#x2F;span&gt;&lt;span&gt;    2 = [2],
&lt;&#x2F;span&gt;&lt;span&gt;    3 = [3],
&lt;&#x2F;span&gt;&lt;span&gt;    3 = [1, 2],
&lt;&#x2F;span&gt;&lt;span&gt;    4 = [1, 3],
&lt;&#x2F;span&gt;&lt;span&gt;    5 = [2, 3],
&lt;&#x2F;span&gt;&lt;span&gt;    6 = [1, 2, 3]
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;&#x2F;h1&gt;
&lt;p&gt;在任意一个子序列中，每一个数组中的元素要么出现在这个子序列中，要么没有出现。一个数组的子序列构成的集合实际上就是它的幂集，假设这个数组有 len 个元素，那么我们可以用长度为 len 位的数唯一地确定这个幂集中的一个子序列：0 表示该位对应的元素没有出现在子序列中，1 则表示出现。所以，上面例子中的所有子序列可以表示为下面的数字：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;text&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-text &quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    0 = [] = 0,
&lt;&#x2F;span&gt;&lt;span&gt;    1 = [1] = 1,
&lt;&#x2F;span&gt;&lt;span&gt;    2 = [2] = 2,
&lt;&#x2F;span&gt;&lt;span&gt;    3 = [3] = 4,
&lt;&#x2F;span&gt;&lt;span&gt;    3 = [1, 2] = 3,
&lt;&#x2F;span&gt;&lt;span&gt;    4 = [1, 3] = 5,
&lt;&#x2F;span&gt;&lt;span&gt;    5 = [2, 3] = 6,
&lt;&#x2F;span&gt;&lt;span&gt;    6 = [1, 2, 3] = 7
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;定义 S 为从表示子序列的数到子序列和的映射，问题转换为我们需要找到一个枚举子序列数 p 的方法满足：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;S(p) 从小到大枚举。&lt;&#x2F;li&gt;
&lt;li&gt;不重复。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;满足第一个要求很简单：只需要将 S(p) 加入到一个小根堆中，使用堆排序。我们知道最小的子序列和一定是 0 对应的子序列 [] ，所以对于一个元素个数大于 0 的已从小到大排序的数组，除了空序列外，最小的子序列一定是 1 对应的 [n[0]]。所以我们只需要找到一个方法，从 1 出发，不重复地找到所有长度小于等于 len 位的数。&lt;&#x2F;p&gt;
&lt;p&gt;假设我们已经枚举了长度小于等于 l 的所有数，现在需要枚举所有长度等于 l + 1 的数。首先，对于长度为 l + 1 的数，其第 l 位一定是 1 ，第 l - 1 位要么是 0 要么是 1 ，这意味着对于一个长度等于 l + 1 的数 p 来说，总是存在唯一一个长度为 l 或 l - 1 的数 q 将第 l 位置一得到的，S(p) = S(q) + n[l] 。同时，这个长度为 l - 1 的数也可以通过一个长度为 l 的数通过将第 l - 1 位置零得到。所以，假设我们现在有一个长度为 l 的数 p ，我们可以求到两个长度为 l + 1 的数对应的 S :&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;text&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-text &quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;S(q1) = S(p) + n[l]
&lt;&#x2F;span&gt;&lt;span&gt;S(q2) = S(p) + n[l] - n[l - 1]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因为每个数的来源是唯一的，所以通过这种方法枚举的数是不重复的，同时所有数都能枚举到（从个数来看），所以这个枚举方法是满足要求的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;perm_sub_sum&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::cmp::Reverse;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::collections::BinaryHeap;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; heap = BinaryHeap::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; sums = vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sort_unstable&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    heap.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;((Reverse(nums[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some((Reverse(sum), i)) = heap.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        sums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(sum);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; i &amp;lt; len - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            heap.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;((Reverse(sum + nums[i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]), i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;            heap.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;((Reverse(sum + nums[i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] - nums[i]), i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    sums
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Exploring Lock-freedom</title>
        <published>2024-03-07T00:00:00+00:00</published>
        <updated>2024-03-07T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/lock-free/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/lock-free/</id>
        
        <content type="html">&lt;h1 id=&quot;tan-suo-wu-suo&quot;&gt;探索无锁&lt;&#x2F;h1&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Stack&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Box&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Node&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;: T,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Box&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Stack&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ head: None }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(head) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head = head.next;
&lt;&#x2F;span&gt;&lt;span&gt;            Some(head.val)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            None
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;: T) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; new_head = Box::new(Node { val, next: None });
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        new_head.next = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head = Some(new_head);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;实现一个只用于单线程的栈是非常容易的。如果想在多线程环境中使用这个栈实现，最简单的方法就是使用一个 &lt;code&gt;Mutex&lt;&#x2F;code&gt; ，它可以在多线程环境中提供互斥的可变引用。然而， &lt;code&gt;Rust&lt;&#x2F;code&gt; 内部默认使用的实现为 &lt;code&gt;pthread_mutex&lt;&#x2F;code&gt; ，性能损失比较大。对于性能敏感的环境，我们更倾向于使用无锁的数据结构。（虽然也存在 &lt;a href=&quot;https:&#x2F;&#x2F;webkit.org&#x2F;blog&#x2F;6161&#x2F;locking-in-webkit&#x2F;&quot;&gt;parking_log&lt;&#x2F;a&gt; 这类在低竞争环境下性能尚可的锁）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;atomic&quot;&gt;Atomic&lt;&#x2F;h2&gt;
&lt;p&gt;在将这个栈实现修改为无锁版本之前，我们先观察一下单线程环境中的实现。为了弹出栈顶的一个元素，我们需要将栈顶赋值为当前栈顶的下一个元素。为了压入一个元素，我们需要构造一个新元素，并将新元素的 &lt;code&gt;next&lt;&#x2F;code&gt; 指针指向原栈顶，然后将栈顶赋值为新元素。使用不提供互斥访问的容器在多个线程共享同一个栈，这违背了 &lt;code&gt;Rust&lt;&#x2F;code&gt; 的所有权规则，可能会引起 Bug ：当一个线程读取 &lt;code&gt;next&lt;&#x2F;code&gt; 后，重新设置 &lt;code&gt;head&lt;&#x2F;code&gt; 前，可能已经有另一个线程将 &lt;code&gt;head&lt;&#x2F;code&gt; 值进行了修改并释放了内存，重新赋值后造成了 use after free 问题。&lt;&#x2F;p&gt;
&lt;p&gt;造成这种错误有两个原因：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;线程调度。在更换 &lt;code&gt;head&lt;&#x2F;code&gt; 值的过程中切换到了另外一个线程执行。&lt;&#x2F;li&gt;
&lt;li&gt;修改扩散。当前线程对值的修改可能还没有扩散到其他核心的缓存中，其他核心可能会读取到以前的值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最朴素的想法就是在重新赋值前检查以下 &lt;code&gt;head&lt;&#x2F;code&gt; 是否是原本的值。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; head = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next = head.next;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The thread may yield CPU here.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; head == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head = next;
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Pop failed.
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然而简单的并不是好的，这种做法不能解决问题：在当前线程判断 &lt;code&gt;head&lt;&#x2F;code&gt; 值之后，仍旧可能发生线程调度；同时对缓存的修改也不一定扩散到了其他核心。所以，要想在不使用锁的情况下解决这个问题，解决方案需要满足一下两个必要条件：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;原子性。比较和赋值作为同一个原子指令，其间不可调度。&lt;&#x2F;li&gt;
&lt;li&gt;内存屏障。修改后其他核心必须知道这个值需要重新加载进入到缓存中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;atomics.html&quot;&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 的 &lt;code&gt;Atomic&lt;&#x2F;code&gt; 可以帮助我们实现这两个条件&lt;&#x2F;a&gt;。一个 &lt;code&gt;Atomic*&lt;&#x2F;code&gt; 提供了 &lt;code&gt;compare_and_swap&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;compare_exchange&lt;&#x2F;code&gt; 方法，可以进行原子地比较和替换。同时作为参数的 &lt;code&gt;Ordering&lt;&#x2F;code&gt; 提供了与其他对内存操作的事件的 &lt;code&gt;happen before&lt;&#x2F;code&gt; 关系进行了抽象（换句话说，提供了类似 &lt;code&gt;fence&lt;&#x2F;code&gt; 指令的功能）。因此，我们可以把栈的实现改成如下这种利用了 &lt;code&gt;Atomic&lt;&#x2F;code&gt; 的形式：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::ptr::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, null_mut, NonNull};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::sync::atomic::AtomicPtr;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::sync::atomic::Ordering::{Acquire, Relaxed, Release};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Stack&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span&gt;: AtomicPtr&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Node&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;: T,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;NonNull&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Stack&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Stack&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Stack {
&lt;&#x2F;span&gt;&lt;span&gt;            head: AtomicPtr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;null_mut&lt;&#x2F;span&gt;&lt;span&gt;()),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Stack&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; head = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(Acquire);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; head == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;null_mut&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (*head).next.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;| n.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;()).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;null_mut&lt;&#x2F;span&gt;&lt;span&gt;()) };
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;compare_and_swap&lt;&#x2F;span&gt;&lt;span&gt;(head, next, Release) == head {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::read(&amp;amp;(*head).val) });
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;: T) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; n = Box::into_raw(Box::new(Node { val: t, next: None }));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; head = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(Relaxed);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                (*n).next = NonNull::new(head);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;compare_and_swap&lt;&#x2F;span&gt;&lt;span&gt;(head, n, Release) == head {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个实现提供了内部可变性，所以 &lt;code&gt;push&lt;&#x2F;code&gt; 和 &lt;code&gt;pop&lt;&#x2F;code&gt; 方法现在只需要接受不可变引用。同时，由于在检查到原本的 &lt;code&gt;head&lt;&#x2F;code&gt; 被修改后会先放弃本次修改，随后重新尝试加入或删除元素，所以这个结构是 &lt;code&gt;Sync&lt;&#x2F;code&gt; 的（内部可变性是互斥的）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nei-cun-xie-lu&quot;&gt;内存泄露&lt;&#x2F;h2&gt;
&lt;p&gt;如果程序中使用了大量的 &lt;code&gt;push&lt;&#x2F;code&gt; 和 &lt;code&gt;pop&lt;&#x2F;code&gt; 操作，以上的实现会发生内存泄露：因为我们根本没有回收内存。注意到在 &lt;code&gt;pop&lt;&#x2F;code&gt; 的实现中，之前在 &lt;code&gt;push&lt;&#x2F;code&gt; 中利用 &lt;code&gt;Box&lt;&#x2F;code&gt; 分配的内存地址作为 &lt;code&gt;head&lt;&#x2F;code&gt; ，但是在我们丢弃 &lt;code&gt;head&lt;&#x2F;code&gt; 时，并没有将其转换为 &lt;code&gt;Box&lt;&#x2F;code&gt; ，这造成了内存泄露。这是为了正确性有意为之。假设我们在 &lt;code&gt;pop&lt;&#x2F;code&gt; 实现中加入了释放内存的代码。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;compare_and_swap&lt;&#x2F;span&gt;&lt;span&gt;(head, next, Release) == head {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; val = Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::read(&amp;amp;(*head).val) });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Box the value and drop it.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ Box::from_raw(head); }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; val;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;aba-problem&quot;&gt;ABA Problem&lt;&#x2F;h2&gt;
&lt;p&gt;现在我们拥有一个栈 &lt;code&gt;A -&amp;gt; B -&amp;gt; C&lt;&#x2F;code&gt; ，每一个字母表示一个内存地址，箭头表示该内存地址的 &lt;code&gt;next&lt;&#x2F;code&gt; 指向的地址。假设我们现在有两个线程同时分别执行下面的操作：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Thread 1 ：弹出一个元素。&lt;&#x2F;li&gt;
&lt;li&gt;Thread 2 : 两次弹出元素，压入一个元素。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;此时， 在 Thread 1 读入 &lt;code&gt;head&lt;&#x2F;code&gt; 值后，调度程序让 Thread 1 停止，同时 Thread 2 开始执行。按照我们的实现，Thread 2 将会释放 A 和 B 对应的内存。在 &lt;code&gt;push&lt;&#x2F;code&gt; 中，Thread 2 申请了一个新内存空间用于安放新的头部节点。此时问题出现：分配器有可能会重用已经被释放的内存。也就是说，分配器分配的新地址可能会是 A 。此时，如果 Thread 1 开始执行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (*head).next.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;| n.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;()).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;null_mut&lt;&#x2F;span&gt;&lt;span&gt;()) };
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Thread 1 stopped here before.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Thread 1 pass the check, because the allocator allocates the same address for the new head.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.head.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;compare_and_swap&lt;&#x2F;span&gt;&lt;span&gt;(head, next, Release) == head {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::read(&amp;amp;(*head).val) });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Because Thread 1 remember the previous next, which points to B, which is dangling now,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; future accesses will panic due to `use after free`! 🤯
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;造成这个问题的原因主要有两个：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在删除一个节点时，我们无法保证没有其他线程正在使用这个指针，因为其他线程可能记录了将被删除的指针的值。&lt;&#x2F;li&gt;
&lt;li&gt;内存复用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;所以在实现了垃圾回收机制的语言不存在这个问题。对于这种问题的解决方案的关注点都在于：我们何时能够释放一个节点。在 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;crossbeam-rs&#x2F;crossbeam&quot;&gt;Crossbeam&lt;&#x2F;a&gt; 中使用了 EBR 来解决这个问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;epoch-based-reclamation&quot;&gt;Epoch-based Reclamation&lt;&#x2F;h2&gt;
&lt;p&gt;实现这个机制需要：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个全局 epoch 计数器（epoch 数值合理范围为 0-2 ）。&lt;&#x2F;li&gt;
&lt;li&gt;每一个 epoch 的全局垃圾容器。&lt;&#x2F;li&gt;
&lt;li&gt;每一个线程的激活标记。&lt;&#x2F;li&gt;
&lt;li&gt;每一个线程的 epoch 计数器。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与传统的垃圾回收不同的是，该机制并不需要通过图找到那些实际不再需要的垃圾，而是通过 epoch 来回收：需要清理的内存在当前 epoch 的两代之前。具体的步骤如下：&lt;&#x2F;p&gt;
&lt;p&gt;当一个线程需要对无锁结构进行操作时，它激活自己的标记，然后将自己的计数器更新至与全局相同的值。如果它需要移除一个内存地址，它所做的并不是直接将其释放，而是 &lt;strong&gt;把内存放入到对应 epoch 的垃圾容器内&lt;&#x2F;strong&gt; 。最后将标记改为未激活。&lt;&#x2F;p&gt;
&lt;p&gt;当一个线程需要进行回收时，需要检查所有的激活线程是否都在当前的 epoch 中。如果都在当前 epoch ，那么就将全局计数器加一，如果修改成功，就可以清理两代之前的内存。这样可以保证所有当前正在被引用的内存都在上一代，且两代之前的内存已经被清理。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>rCore CH3 CH4 Note</title>
        <published>2023-11-08T00:00:00+00:00</published>
        <updated>2023-11-08T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/rcore-ch3-4/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/rcore-ch3-4/</id>
        
        <content type="html">&lt;h1 id=&quot;rcore-ch3-ch4-bi-ji&quot;&gt;rCore CH3 CH4 笔记&lt;&#x2F;h1&gt;
&lt;p&gt;第三章与第四章主要讲了进程控制流切换以及进程间的隔离。在没有引入虚拟地址之前，两个进程通过使用位于不同地址的内存来区分不同的进程，这就需要我们在编写程序时，提前写好程序使用的内存地址，同时使用了相同的地址的程序无法同时进行。为了解决这个问题，我们引入了虚拟地址——通过地址转换空间，将应用的虚拟地址转换为实际的物理地址。通过这种方法，可以在编写程序时不再关注具体的内存地址分配，而是使用相同的地址，通过不同的映射来获取应用的内存。因此，这篇笔记主要聚焦于如何使用虚拟地址来进行进程隔离，同时虚拟地址给控制流切换带来的问题与解决方法。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ye-biao&quot;&gt;页表&lt;&#x2F;h2&gt;
&lt;p&gt;MMU 通过查找页表来将虚拟地址转换为物理地址。RISC-V 使用的页表项格式如下（左侧为高位）：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Reserved 10bits&lt;&#x2F;th&gt;&lt;th&gt;PPN[2] 26bits&lt;&#x2F;th&gt;&lt;th&gt;PPN[1] 9bits&lt;&#x2F;th&gt;&lt;th&gt;PPN[0] 9bits&lt;&#x2F;th&gt;&lt;th&gt;RSW 2bits&lt;&#x2F;th&gt;&lt;th&gt;D&lt;&#x2F;th&gt;&lt;th&gt;A&lt;&#x2F;th&gt;&lt;th&gt;G&lt;&#x2F;th&gt;&lt;th&gt;U&lt;&#x2F;th&gt;&lt;th&gt;X&lt;&#x2F;th&gt;&lt;th&gt;W&lt;&#x2F;th&gt;&lt;th&gt;R&lt;&#x2F;th&gt;&lt;th&gt;V&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;每一个页表项使用了 8 个字节。虚拟地址和物理地址分别使用了 39bits 和 56bits ，其中低 12 位是页内偏移，所以虚拟地址空间中有 2 ^ 27 个内存页面。如果我们直接使用普通的线性表作为页表，为了能够在页表获取每一个虚拟内存页面对应的物理页面，这个页表需要 2 ^ 27 * 8 bytes = 2 ^ 30 bytes = 1 GB 的内存作为页表，这显然是不经济的——你能够接受每一个应用程序都至少占用 1GB 内存吗？为了解决这个问题，可以使用多级页表。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duo-ji-ye-biao&quot;&gt;多级页表&lt;&#x2F;h3&gt;
&lt;p&gt;使用多级页表可以省下多少内存？以 RV39 为例，页内偏移一共 12 位，一个内存页面的大小为 2 ^ 12 bytes = 4 KB ，每一个页面可以放下 512 个页表项（正好对应虚拟页号的 9 位），共 3 级页表，总共只需要 (1 root page table + 2 ^ 9 second level page tables + 2 ^ 18 third level page tables) * 512 bytes = 128 MB 。如此，我们只需要将根页表的地址写入 satp 寄存器，MMU 就可以自动寻找对应的物理地址。&lt;&#x2F;p&gt;
&lt;p&gt;多级页表的设计类似于数据结构中的字典树，使用 3 个 9 位的页号分段进行索引。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;aaaaaaaaa bbbbbbbbb ccccccccc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;使用 &lt;code&gt;aaaaaaaaa&lt;&#x2F;code&gt; 在根页表中查到对应的物理地址 A ，在 A 处的二级页表中查询 &lt;code&gt;bbbbbbbbb&lt;&#x2F;code&gt; ，以此类推，直到查询到叶子节点。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-shou-dong-fang-wen-cao-zuo-ye-biao&quot;&gt;如何手动访问 &#x2F; 操作页表&lt;&#x2F;h3&gt;
&lt;p&gt;我们可能需要对页表的项进行修改，如何进行？&lt;&#x2F;p&gt;
&lt;p&gt;当我们开启页表后，直接通过页表的物理地址去查询和修改似乎已经不可能了——我们输入的物理地址会经由 MMU 进行一次地址变换，无法保证还是需要访问的地址。这里提供两种方法。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xian-xing-ying-she&quot;&gt;线性映射&lt;&#x2F;h4&gt;
&lt;p&gt;将页表的页面地址进行线性映射。具体来说，我们将页号为 VP 的虚拟页面映射到页号为 VP + d 的物理页面上。如果 d 为 0 ，这也被称作直接映射。&lt;&#x2F;p&gt;
&lt;p&gt;在 rCore 的实现中就采用了这种方式。rCore 将页表存在的内存区域，也就是内核程序的堆进行了直接映射，我们可以直接使用物理地址作为虚拟地址进行查询，非常方便。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;di-gui-ying-she&quot;&gt;递归映射&lt;&#x2F;h4&gt;
&lt;p&gt;另一种方法是，将页表的某一个页表项指向它自己。例如，将第 511 个页表项指向自身，那么在三级页表的情况下，我们可以使用页号 0b111_111_111_111_111_111 = 0x7ffffff 来访问根页表。而访问根页表的第 0 个二级页表，可以使用页号 0b000_000_000_111_111_111_111_111_111 = 0x3ffff 或 0b111_111_111_111_111_111_000_000_000 = 0x7fffe00 。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kong-zhi-liu-qie-huan&quot;&gt;控制流切换&lt;&#x2F;h2&gt;
&lt;p&gt;当应用交出 CPU 时，会陷入到内核中进行任务切换。通过切换内核的控制流，将内核态的寄存器的值更换为另一个控制流的值，最终可以切换到另一个应用的执行。当需要切换内核控制流时，需要调用 &lt;code&gt;switch&lt;&#x2F;code&gt; 函数，将寄存器的进行更换。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;# a0: pre task context pointer&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1: cur task context pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__switch:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # Save &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    sd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a0)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # Save ra
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    sd ra&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a0)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # Save sn
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .set n&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .rept &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        SAVE_SN %n
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        .set n&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .endr
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # Load &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ra&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sn from the next task context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    ld &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    ld ra&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .set n&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .rept &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        LOAD_SN %n
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        .set n&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .endr
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # Because &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;has been changed to the new context&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # this &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;will go back to the next task&amp;#39;s control flow
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;切换控制流的关键在于重新加载了 sp ，ra 寄存器的值。&lt;code&gt;ra&lt;&#x2F;code&gt; 寄存器管理了返回地址，执行 &lt;code&gt;ret&lt;&#x2F;code&gt; 指令后会跳转到新任务的执行 &lt;code&gt;__switch&lt;&#x2F;code&gt; 后的内核控制流。&lt;code&gt;sp&lt;&#x2F;code&gt; 寄存器管理栈顶的位置，可以用于保存和恢复应用的用户态寄存器，实现从内核态返回到新任务的用户态。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;di-zhi-kong-jian-ping-hua-qie-huan&quot;&gt;地址空间平滑切换&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;di-zhi-kong-jian-qie-huan-dai-lai-de-wen-ti&quot;&gt;地址空间切换带来的问题&lt;&#x2F;h3&gt;
&lt;p&gt;由于从内核态中的控制流切换，以及用户态陷入内核态，内核态返回用户态需要切换页表，切换页表可能导致 &lt;code&gt;pc&lt;&#x2F;code&gt; 失效——指向没有有效指令的区域。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-ping-hua-qie-huan&quot;&gt;如何平滑切换&lt;&#x2F;h3&gt;
&lt;p&gt;将需要进行页表切换的部分代码在所有地址空间中都映射到同一块区域。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>rCore CH2 Note</title>
        <published>2023-10-19T00:00:00+00:00</published>
        <updated>2023-10-19T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/rcore-ch2/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/rcore-ch2/</id>
        
        <content type="html">&lt;h1 id=&quot;rcore-ch2-bi-ji&quot;&gt;rCore Ch2 笔记&lt;&#x2F;h1&gt;
&lt;p&gt;最近开始刷 &lt;a href=&quot;https:&#x2F;&#x2F;rcore-os.cn&#x2F;rCore-Tutorial-Book-v3&#x2F;index.html&quot;&gt;rCore 第三版教程&lt;&#x2F;a&gt; ，尝试用 Rust 在 RISC-V 模拟器上实现一个操作系统内核。在这里留下一些实现过程中踩的坑以及相关的笔记。笔记从教程的第二章开始编号。之所以不从第一章开始，是因为第一章的内容不是很多，所以就和第二章一起写了，如果之前有写过操作系统相关或者 bare metal 的代码，很快就能上手。&lt;&#x2F;p&gt;
&lt;p&gt;对应的代码在&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;NaviHX&#x2F;rcore&#x2F;tree&#x2F;ch2&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-dong-liu-cheng&quot;&gt;启动流程&lt;&#x2F;h2&gt;
&lt;p&gt;RISCV-V 芯片启动，进行一些简单的初始化后，就将运行放置到内存地址 0x1000 处的 SBI 代码（在我们平常使用的电脑上，负责同样功能的程序被叫做 BIOS ）对芯片进行初始化操作。在使用 qemu 运行的 rCore 内核实验中，我们使用了 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rustsbi&#x2F;rustsbi-qemu&quot;&gt;rustsib-qemu&lt;&#x2F;a&gt; 作为内核的引导程序。在完成初始化工作后， CPU 将会转到 Supervisor 特权级，并且跳转到 0x80200000 继续执行。关于特权级的描述稍后进行。&lt;&#x2F;p&gt;
&lt;p&gt;为了让我们的内核可以在 SBI 完成工作后可以运行，我们需要使用链接器脚本将内核的入口地址放到地址 0x80200000 处。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;将入口函数的段标记为 .text.entry 。&lt;&#x2F;li&gt;
&lt;li&gt;在 linker.ld 中将 .text.entry 放到 0x80200000&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;SECTIONS {
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    . = 0x80200000
&lt;&#x2F;span&gt;&lt;span&gt;    .text : {
&lt;&#x2F;span&gt;&lt;span&gt;        *(.text.entry)
&lt;&#x2F;span&gt;&lt;span&gt;        *(.text .text.*)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;sbi-ti-gong-de-fu-wu&quot;&gt;SBI 提供的服务&lt;&#x2F;h3&gt;
&lt;p&gt;就像操作系统可以给应用程序提供系统调用的接口一样，SBI 也为 Supervisor 特权级运行的内核代码提供了接口使用硬件的服务。按照 SBI 的标准，我们可以向下面这样调用 SBI 提供的接口。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ecall&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;extension&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fid&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: [3; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; ret;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ecall&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;inlateout&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x10&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) arg[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] =&amp;gt; ret,
&lt;&#x2F;span&gt;&lt;span&gt;            in(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x11&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) arg[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            in(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x12&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) arg[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            in(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x16&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) fid,
&lt;&#x2F;span&gt;&lt;span&gt;            in(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x17&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) extension,
&lt;&#x2F;span&gt;&lt;span&gt;        );
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    ret
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的例子可以调用一个最多三个参数的 SBI 接口。 ecall 指令可以让我们将 CPU 的特权级提升（或者不变），我们实现的操作系统内核也可以提供类似的 ABI 接口供应用程序调用，也就是系统调用。与 ecall 指令相对的，还有一个 eret 指令，可以将 CPU 退回到之前的特权级，关于中断与异常的部分会在「处理中断与异常」的部分作更多的介绍。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;riscv-v-call-convention&quot;&gt;RISCV-V Call Convention&lt;&#x2F;h2&gt;
&lt;p&gt;当我们编写内核代码时，难免会进行函数调用。函数调用的过程中，可能会使用一些寄存器，其中的数值可能会被覆盖，为了让调用函数的过程可以成功继续执行，我们需要恢复调用者的寄存器状态。哪些寄存器需要保存，哪些不需要，每个寄存器什么用处，这就是 Call Conventions 「调用约定」（如果你曾经写过汇编，或者做过 FFI 相关的项目，你应该知道我在说什么）。&lt;&#x2F;p&gt;
&lt;p&gt;下面是 RISC-V 的调用约定。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Register Number&lt;&#x2F;th&gt;&lt;th&gt;Usage&lt;&#x2F;th&gt;&lt;th&gt;Saver&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;zero&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;Hard-wired zero&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ra&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;Return address&lt;&#x2F;td&gt;&lt;td&gt;Caller&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;sp&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;Stack pointer&lt;&#x2F;td&gt;&lt;td&gt;Callee&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;gp&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;Global pointer&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;tp&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;Thread pointer&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;t0-2&lt;&#x2F;td&gt;&lt;td&gt;5-7&lt;&#x2F;td&gt;&lt;td&gt;Temporaries&lt;&#x2F;td&gt;&lt;td&gt;Caller&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;s0&#x2F;fp&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;Frame pointer&lt;&#x2F;td&gt;&lt;td&gt;Callee&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;s1&lt;&#x2F;td&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;Saved register&lt;&#x2F;td&gt;&lt;td&gt;Callee&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;a0-1&lt;&#x2F;td&gt;&lt;td&gt;10-11&lt;&#x2F;td&gt;&lt;td&gt;Function arguments &#x2F; Return values&lt;&#x2F;td&gt;&lt;td&gt;Caller&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;a2-7&lt;&#x2F;td&gt;&lt;td&gt;12-17&lt;&#x2F;td&gt;&lt;td&gt;Function arguments&lt;&#x2F;td&gt;&lt;td&gt;Caller&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;s2-11&lt;&#x2F;td&gt;&lt;td&gt;18-27&lt;&#x2F;td&gt;&lt;td&gt;Saved registers&lt;&#x2F;td&gt;&lt;td&gt;Callee&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;t3-6&lt;&#x2F;td&gt;&lt;td&gt;28-31&lt;&#x2F;td&gt;&lt;td&gt;Temporaries&lt;&#x2F;td&gt;&lt;td&gt;Caller&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;在我们进行函数调用的地方，编译器都会为我们生成类似的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__function:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addi &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;# 分配栈
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    sd ra&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;56&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;) # 保存返回地址
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    sd s0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;48&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;) # 保存 frame pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addi s0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;# 新的 frame pointer
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # Some code
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    ld ra&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;56&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;) # 恢复返回地址
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    ld s0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;48&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;) # 恢复 frame pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addi &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;# 恢复栈
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为了让我们的内核支持函数调用，我们需要做到以下几点。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;为函数调用提供一个栈，将 sp 指向栈的顶部（因为栈是向下增长的）。&lt;&#x2F;li&gt;
&lt;li&gt;为每一次函数调用的周围做好执行环境的保存与恢复工作。这一项工作通常有编译器帮助我们执行。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;te-quan-ji&quot;&gt;特权级&lt;&#x2F;h2&gt;
&lt;p&gt;为了让应用程序出现故障时，不会让整个计算机停止运行，同时为了限制应用程序进行某些需要特权的操作， RISC-V 提供了多个特权级： Machine 、Hypervisor 、Supervisor 、User 。当应用程序发生错误时，会陷入到内核中进行处理，终止应用程序的执行，恢复整个系统的运行。也可以使用 ecall 调用系统提供的服务。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ecall : 可以使得 CPU 提升到不低于当前特权级的状态。&lt;&#x2F;li&gt;
&lt;li&gt;eret : 可以使得 CPU 恢复到不高于当前特权级的状态。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这两条命令进行组合，就可以实现系统调用的功能，向应用程序提供服务。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chu-li-zhong-duan-he-yi-chang&quot;&gt;处理中断和异常&lt;&#x2F;h2&gt;
&lt;p&gt;在我们实现的内核中，我们要做的事情非常简单：当应用程序 trap 到内核中后，调用相应的代码处理异常 &#x2F; 中断，最后返回用户态执行。在处理中断的过程中，需要注意这些寄存器：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CSR&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;sstatus&lt;&#x2F;td&gt;&lt;td&gt;发生 trap 前 CPU 处于的特权级&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;sepc&lt;&#x2F;td&gt;&lt;td&gt;发生 trap 前执行的最后一条指令的地址&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;scause&lt;&#x2F;td&gt;&lt;td&gt;描述 trap 的原因&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;stval&lt;&#x2F;td&gt;&lt;td&gt;trap 的附加信息&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;stvec&lt;&#x2F;td&gt;&lt;td&gt;处理 trap 的代码地址&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;为了能够处理中断，我们需要完成下面的工作：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;编写处理 trap 的代码，把地址写入 stvec 寄存器中。这里 stvec 被设置为了 Direct 模式，直接写入地址就行了。&lt;&#x2F;li&gt;
&lt;li&gt;编写恢复用户态的代码。&lt;&#x2F;li&gt;
&lt;li&gt;在进入 trap 后，需要将 sp 设置到内核栈。返回时重新指向用户栈。（用 sscratch 保存）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;为了正确恢复用户态的执行，我们需要保存所有通用寄存器的数值到内核栈中——这里不存在由调用者保存与由被调用者保存，所有的寄存器在内核处理其间都有可能被使用。同时需要保存 sepc 的寄存器的值，这里考虑到了嵌套 trap 与切换任务的可能（在 Ch3 中有涉及）。&lt;&#x2F;p&gt;
&lt;p&gt;在 rCore 的代码中我们可以发现这样一个结构。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__alltraps:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # 保存状态到栈上
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # 调用处理 trap 各种情况的函数
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__restore:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # 恢复状态
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    # 返回用户态
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    sret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里看似有两个函数 __alltraps 和 __restore ，但在调用 alltraps 的过程中只有一个函数，因为在 restore 前并没有 ret 。restore 可以用于运行第一个任务：构造一个保存用户态状态的地址，将 sp 指向这个地址，调用 restore 就可以运行构造的程序。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yun-xing-ying-yong-cheng-xu&quot;&gt;运行应用程序&lt;&#x2F;h2&gt;
&lt;p&gt;通过构造「用户态寄存器状态」调用 restore 即可执行。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Binary Search</title>
        <published>2023-09-12T00:00:00+00:00</published>
        <updated>2023-09-12T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/binary-search/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/binary-search/</id>
        
        <content type="html">&lt;h1 id=&quot;binary-search&quot;&gt;Binary Search&lt;&#x2F;h1&gt;
&lt;p&gt;最常见的算法之一。因为每次写出来的都不一样 XD ，所以在这里留一个笔记。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;suan-fa-shu-chu-yu-xun-huan-bu-bian-liang&quot;&gt;算法输出与循环不变量&lt;&#x2F;h2&gt;
&lt;p&gt;这里介绍的二分搜索算法可以寻找目标元素的最小索引（假设数组已经从小到大排序），当无法找到时，则返回目标元素可以插入的位置（也就是比多少个元素大）。&lt;&#x2F;p&gt;
&lt;p&gt;已知已排序的数组 elem ，定义两个变量 left &amp;amp; right ，满足&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;= left &amp;lt; right &amp;lt;= elem.len()&lt;&#x2F;li&gt;
&lt;li&gt;target 大于 elem[..left] 中的所有元素&lt;&#x2F;li&gt;
&lt;li&gt;target 小于等于 elem[right..] 中的所有元素&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;每次循环都要缩小 left - right 的范围来找到目标元素。因为需要对数组进行排序和比较大小，所以数组元素 &#x2F; 数组元素对应的 key 必须是全序的。&lt;&#x2F;p&gt;
&lt;p&gt;缩小范围的步骤为&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;比较中间元素的与目标元素的大小&lt;&#x2F;li&gt;
&lt;li&gt;如果目标元素 &amp;gt;= 中间元素， right := mid&lt;&#x2F;li&gt;
&lt;li&gt;如果目标元素 &amp;lt; 中间元素， left := mid + 1&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;缩小范围的过程一直保持后两个不变量，所以跳出循环的条件应该是第一个不变量不成立。此时满足 target &amp;gt; elem[..left] and target &amp;lt;= elem[right..] （注意这里 ..left 不包括 left ），由于不满足第一个不变量，此时 left &amp;gt;= right 。由于缩小范围的过程中，每次缩小时都满足 right&#x27; = mid or left&#x27; = mid + 1 ，而 left &amp;lt;= mid &amp;lt; right ，所以最后一次缩小后，left == right 。考虑到后两个不变量成立，此时 left 就是目标元素的最小索引。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;binary_search&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elem&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[T], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span&gt;: T) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    T: Ord
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::cmp::Ordering;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = elem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; left = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; right = len;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; left &amp;lt; right {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mid = left + ((right - left) &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; target.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cmp&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;elem[mid]) {
&lt;&#x2F;span&gt;&lt;span&gt;            Ordering::Less | Ordering::Equal =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                right = mid;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            Ordering::Greater =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                left = mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; elem[left] == mid { Ok(left) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ Err(left) }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;li-ti-xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu&quot;&gt;例题：寻找两个正序数组的中位数&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;median-of-two-sorted-arrays&#x2F;&quot;&gt;题目描述&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;本题的关键是确定如何进行二分搜索。我们假设最终的中位数大于等于 nums1 ， nums2 的前 id1 ， id2 个元素。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一点，因为我们有两个正序数组，在没有将它们合并的情况下，如何进行二分搜索？这里的关键是，我们确定了在其中一个数组的索引，我们能不能确定在另一个数组的索引。首先我们假设两个数组 nums1 和 nums2 ，其中，nums1.len() &amp;lt;= nums2.len() ，如果我们确定了在 nums1 中的索引，有没有办法确定 nums2 的索引。注意到中位数的性质，它一定比一半的数组元素要大，这意味着 id1 + id2 = (len1 + len2) &#x2F; 2 ，那么另一个数组的索引可以通过 id2 = (len1 + len2) &#x2F; 2 - id1 来计算。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第二点，二分搜索的键值是什么？这也需要利用中位数的性质。中位数比前一半的数大，比后一半的数小，转换到两个数组的情况下可以这样表示：nums1[id1], nums2[id2] &amp;gt;= nums1[..id1] U nums2[..id2] ，且对于 id &amp;lt; id1 ， nums1[id] &amp;lt; nums2[id2] ，对 nums2 同理。这个性质中体现了单调性：只有 id &amp;gt;= id1 ，才有 nums1[id] &amp;gt;= nums2[id2 - 1] ，而 id2 与 id1 有关。接下来的问题就是利用二分搜索查找 id1 了。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;find_median_sorted_arrays&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums1&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums2&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;binary_search_by_key&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elems&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key_fn&lt;&#x2F;span&gt;&lt;span&gt;: impl Fn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::cmp::Ordering;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = elems.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; left, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; right) = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, len);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; left &amp;lt; right {
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{left}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{right}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mid = left + ((right - left) &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mid_key = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;key_fn&lt;&#x2F;span&gt;&lt;span&gt;(elems[mid]);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; target.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cmp&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;mid_key) {
&lt;&#x2F;span&gt;&lt;span&gt;                Ordering::Less | Ordering::Equal =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                    right = mid;
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                Ordering::Greater =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                    left = mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; left_key = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;key_fn&lt;&#x2F;span&gt;&lt;span&gt;(elems[left]);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; left_key == target { Ok(left) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ Err(left) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; len1, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; len2) = (nums1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(), nums2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = len1 + len2;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mid = len &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; len1 &amp;gt; len2 {
&lt;&#x2F;span&gt;&lt;span&gt;        std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; len1, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; len2);
&lt;&#x2F;span&gt;&lt;span&gt;        std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; nums1, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; nums2);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elems: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..=len1).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; search_res = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;binary_search_by_key&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;elems[..], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id1 = id;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id2 = mid - id1;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; id1 == len1 {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            nums1[id1] &amp;gt;= nums2[id2 - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id1 = search_res;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id2 = mid - id1;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; len &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *(nums1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(id1).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(nums2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(id2).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;))) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; left = *(nums1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(id1 - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MIN&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(nums2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(id2 - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MIN&lt;&#x2F;span&gt;&lt;span&gt;)));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; right = *(nums1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(id1).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(nums2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(id2).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;)));
&lt;&#x2F;span&gt;&lt;span&gt;        (left as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;+ right as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2.
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Lowest Common Ancestor</title>
        <published>2023-09-11T00:00:00+00:00</published>
        <updated>2023-09-11T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/lowest-common-ancestor/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/lowest-common-ancestor/</id>
        
        <content type="html">&lt;h1 id=&quot;lowest-common-ancestor&quot;&gt;Lowest Common Ancestor&lt;&#x2F;h1&gt;
&lt;p&gt;给定一棵树与树中的两个节点，如何找出这两个节点的最近公共祖先。最近公共祖先的定义为，对于一个有根树 T 与其中的两个节点 p ， q ，p 与 q 的最近公共祖先为一个节点 x ，满足以 x 为根的子树同时包含了节点 p 与 q ，且 x 的深度尽可能的深。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;po-su-zuo-fa-dfs&quot;&gt;朴素做法： DFS&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;RefNode = RefCell&amp;lt;TreeNode&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;RcNode = Rc&amp;lt;RefNode&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;PtrNode = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const&lt;&#x2F;span&gt;&lt;span&gt; RefNode;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;MaybeNode = Option&amp;lt;RcNode&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;Res {
&lt;&#x2F;span&gt;&lt;span&gt;    Both(MaybeRcNode), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; LCA
&lt;&#x2F;span&gt;&lt;span&gt;    Only1,
&lt;&#x2F;span&gt;&lt;span&gt;    Only2,
&lt;&#x2F;span&gt;&lt;span&gt;    Neither,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;dfs&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;root&lt;&#x2F;span&gt;&lt;span&gt;: MaybeRcNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node1&lt;&#x2F;span&gt;&lt;span&gt;: RcNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node2&lt;&#x2F;span&gt;&lt;span&gt;: RcNode) -&amp;gt; Res {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(root) = root {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; left = root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;borrow_mut&lt;&#x2F;span&gt;&lt;span&gt;().left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; right = root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;borrow_mut&lt;&#x2F;span&gt;&lt;span&gt;().right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;(root == node1, root == node2, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dfs&lt;&#x2F;span&gt;&lt;span&gt;(left, node1, node2), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dfs&lt;&#x2F;span&gt;&lt;span&gt;(right, node1, node2)) {
&lt;&#x2F;span&gt;&lt;span&gt;            (_, _, Both(ans), _) | (_, _, _, Both(ans)) =&amp;gt; Both(ans),
&lt;&#x2F;span&gt;&lt;span&gt;            (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, _) =&amp;gt; Both(Some(root)),
&lt;&#x2F;span&gt;&lt;span&gt;            (_, _, Only1, Only2) | (_, _, Only2, Only1) =&amp;gt; Both(Some(root)),
&lt;&#x2F;span&gt;&lt;span&gt;            (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, Only2, _) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, _, Only2) =&amp;gt; Both(Some(root)),
&lt;&#x2F;span&gt;&lt;span&gt;            (_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, Only1, _) | (_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, Only1) =&amp;gt; Both(Some(root)),
&lt;&#x2F;span&gt;&lt;span&gt;            (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, Only1, _) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, _, Only1) =&amp;gt; Only1,
&lt;&#x2F;span&gt;&lt;span&gt;            (_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, Only2, _) | (_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, _, Only2) =&amp;gt; Only2,
&lt;&#x2F;span&gt;&lt;span&gt;            (_, _, Only1, Only1) =&amp;gt; Only1,
&lt;&#x2F;span&gt;&lt;span&gt;            (_, _, Only2, Only2) =&amp;gt; Only2,
&lt;&#x2F;span&gt;&lt;span&gt;            _ =&amp;gt; Neither,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Res::Neither
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;duo-ci-cha-xun&quot;&gt;多次查询&lt;&#x2F;h2&gt;
&lt;p&gt;上面的做法对于单次查询比较有效，只需要将树中的所有节点遍历一遍就可以找到最近公共祖先。但是如果我们将要对同一棵树进行多次的 LCA 查询，这种做法的效率就无法接受了。我们可不可以只遍历一次树，利用树的信息来寻找 LCA 呢？&lt;&#x2F;p&gt;
&lt;p&gt;通过一次遍历，从树中我们可以得到任意一个节点的深度与父亲节点信息。因此我们可以通过下面这个步骤来寻找 LCA ：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;将两个节点指针中，深度较大的指针向上移动至同一个深度。&lt;&#x2F;li&gt;
&lt;li&gt;比较两个节点指针，如果相同，则这个节点就是 LCA ，否则跳至第三步。&lt;&#x2F;li&gt;
&lt;li&gt;将两个节点指针分别移动到他们的父节点。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; depth: HashMap&amp;lt;PtrNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = HashMap::new();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; parent: HashMap&amp;lt;PtrNode, RcNode&amp;gt; = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_info&lt;&#x2F;span&gt;&lt;span&gt;(root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(), None, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; depth, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; parent); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; fn build_info(root, parent_node: MaybeNode, depth, parent);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; depth1 = depth[&amp;amp;(node1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; depth2 = depth[&amp;amp;(node2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Make sure depth1 &amp;lt;= depth2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; depth2 &amp;lt; depth1 {
&lt;&#x2F;span&gt;&lt;span&gt;    std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; depth1, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; depth2);
&lt;&#x2F;span&gt;&lt;span&gt;    std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; node1, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; node2);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Raise node1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; d = depth2 - depth1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;_ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..d {
&lt;&#x2F;span&gt;&lt;span&gt;    node2 = parent[&amp;amp;(node2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Raise both until equal
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; node1 != node2 {
&lt;&#x2F;span&gt;&lt;span&gt;    node1 = parent[&amp;amp;(node1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    node2 = parent[&amp;amp;(node2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; LCA
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; node1;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;bei-zeng&quot;&gt;倍增&lt;&#x2F;h2&gt;
&lt;p&gt;在上面这个过程中，我们发现后续的 Raise 过程的时间复杂度与深度有关。当二叉树退化为链表时，时间复杂度退化为整个树的节点数目，不算十分理想。我们是否可以加速 Raise 过程呢？&lt;&#x2F;p&gt;
&lt;p&gt;我们不妨修改一下 parent 的定义，将其通过索引节点指针得到的结果变成一个列表（而不是直接父节点），第 i 个位置的元素表示这个节点的第 2^0 个父节点。这样的定义满足如下的性质：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;parent(parent(node, i-1), i-1) == parent(node, i)&lt;&#x2F;li&gt;
&lt;li&gt;交换律 parent(parent(node, i), j) == parent(parent(node, j), i)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;第一条性质我们可以使用在构建 parent 表中。对于任意一个节点的 parent 列表，我们可以通过下面的过程计算。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;将这个节点的直接父节点作为它的 parent 列表的第 0 元素&lt;&#x2F;li&gt;
&lt;li&gt;let i = 1&lt;&#x2F;li&gt;
&lt;li&gt;使用性质一， &lt;code&gt;parent[node][i] = parent[parent[node][i-1]][i-1]&lt;&#x2F;code&gt;  ，如果此处的索引超出界限则跳出循环&lt;&#x2F;li&gt;
&lt;li&gt;i += 1&lt;&#x2F;li&gt;
&lt;li&gt;跳转到第三步&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在构建好 parent 表之后，可以通过这张表将节点指针上升任意 2 的整数次幂高度。我们接下来考虑，如何通过这个表，将节点指针上升任意高度 d 。首先，对于任意一个正整数 d ，我们可以将其转换为一个关于 2 的多项式。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;d = (a_n)2^n + (a_(n-1))2^(n-1) + ... + (c_0)2^0
&lt;&#x2F;span&gt;&lt;span&gt;c_i = 0 | 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这意味着我们可以通过 n 次跳跃就可以将节点指针提升任意高度。同时由于性质二交换律，我们可以任意组织跳跃的顺序。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; raise height d
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; i = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; d &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    node = parent[&amp;amp;(node.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const&lt;&#x2F;span&gt;&lt;span&gt;)][i]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Assume element exists
&lt;&#x2F;span&gt;&lt;span&gt;    i += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    d &amp;gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这一段代码可以代替将较低的节点指针提升到相同高度的部分。&lt;&#x2F;p&gt;
&lt;p&gt;剩下的将两个节点提升到 LCA 的过程也可以通过新的 parent 表进行优化——我们不再需要将节点指针逐次提升一个高度，而是跳转到 parent 表中一个恰好没有使节点指针相同的高度。当没有一个高度可以使两个指针不同时，则父节点就是 LCA 。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wan-zheng-dai-ma&quot;&gt;完整代码&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;RefNode = RefCell&amp;lt;TreeNode&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;RcNode = Rc&amp;lt;RefNode&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;PtrNode = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const&lt;&#x2F;span&gt;&lt;span&gt; RefNode;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;MaybeNode = Option&amp;lt;RcNode&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;lowest_common_ancestor&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;root&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;q&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::collections::HashMap;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;build_parent&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;root&lt;&#x2F;span&gt;&lt;span&gt;: MaybeNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;depth&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parent&lt;&#x2F;span&gt;&lt;span&gt;: MaybeNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parents&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;HashMap&amp;lt;PtrNode, Vec&amp;lt;RcNode&amp;gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;depths&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;HashMap&amp;lt;PtrNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(root) = root {
&lt;&#x2F;span&gt;&lt;span&gt;            depths.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;(root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_), depth);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(parent) = parent {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; ps: Vec&amp;lt;RcNode&amp;gt; = vec![parent.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()];
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; i = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(p) = parents
&lt;&#x2F;span&gt;&lt;span&gt;                        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;(ps[i].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_))
&lt;&#x2F;span&gt;&lt;span&gt;                        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;and_then&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pv&lt;&#x2F;span&gt;&lt;span&gt;| pv.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(i))
&lt;&#x2F;span&gt;&lt;span&gt;                    {
&lt;&#x2F;span&gt;&lt;span&gt;                        ps.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(p.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;                        i += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                parents.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_, ps);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; left = root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;borrow_mut&lt;&#x2F;span&gt;&lt;span&gt;().left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; right = root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;borrow_mut&lt;&#x2F;span&gt;&lt;span&gt;().right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(pdl, qdl) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_parent&lt;&#x2F;span&gt;&lt;span&gt;(left, depth + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, Some(root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()), parents, depths);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(pdr, qdr) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_parent&lt;&#x2F;span&gt;&lt;span&gt;(right, depth + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, Some(root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()), parents, depths);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;(Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; p), Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; q)) = (p, q) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; parents = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; depths = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_parent&lt;&#x2F;span&gt;&lt;span&gt;(root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, None, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; parents, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; depths);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;(Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; pd), Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; qd)) = (depths.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;(p.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)), depths.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;(q.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_))) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Make sure that pd &amp;lt;= qd
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; pd &amp;gt; qd {
&lt;&#x2F;span&gt;&lt;span&gt;                std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; p, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; q);
&lt;&#x2F;span&gt;&lt;span&gt;                std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; pd, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; qd);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Jump to the same level
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; i = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; d = qd - pd;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; d &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; d &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    q = parents[&amp;amp;(q.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)][i].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                    println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{i}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                i += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                d &amp;gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Jump as far as they can, until find the LCA
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; p != q {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; p_depth == q_depth, so p_len == q_len
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = parents[&amp;amp;(p.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..len).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; pp = parents[&amp;amp;(p.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)][i].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; qp = parents[&amp;amp;(q.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;_)][i].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; pp != qp || i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                        p = pp;
&lt;&#x2F;span&gt;&lt;span&gt;                        q = qp;
&lt;&#x2F;span&gt;&lt;span&gt;                    } 
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; LCA
&lt;&#x2F;span&gt;&lt;span&gt;            Some(p)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            None
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Search in Rotated Sorted Array</title>
        <published>2023-09-09T00:00:00+00:00</published>
        <updated>2023-09-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/search-in-rotated-sorted-array/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/search-in-rotated-sorted-array/</id>
        
        <content type="html">&lt;h1 id=&quot;search-in-rotated-sorted-array&quot;&gt;Search in Rotated Sorted Array&lt;&#x2F;h1&gt;
&lt;p&gt;如果我们需要在一个已经排好序的数组中寻找某个元素，首选的方法肯定是进行二分搜索——因为在排序完成的数组中搜索满足单调性。但是将这个数组进行旋转后，是否依旧能进行二分搜索呢？&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;123456 -&amp;gt; 3456 12
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个例子展示了数组旋转的结果：将整个数组旋转了 4 位。数组的旋转定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;原数组 N 经过 x (x &amp;gt; 0) 位旋转后得到的新数组 N&amp;#39; 满足：
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;N&amp;#39;[i] = N[i - x] ，索引值需要对数组长度进行取模。
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;dan-diao-xing&quot;&gt;单调性&lt;&#x2F;h2&gt;
&lt;p&gt;经过旋转后的排序数组已经不再拥有单调性，但是一部分元素内部仍然具有单调性。比如说下面这个数组：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;3456 | 12
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;被分割开的部分是数组本来的起始位置，在它的两侧，元素分别拥有单调性。这意味着，我们任意选择一个索引把数组分为两侧，至少有一侧的元素可以保持单调：因为数组原本的起始位置只可能落在一侧，另一侧一定是单调的。&lt;&#x2F;p&gt;
&lt;p&gt;根据这个性质，我们可以把数组从某个索引分为两个部分，一个部分拥有单调性，而另一个部分（不一定）没有单调性。在有单调性的一侧，我们只需要将搜索的目标值与起始位置和末尾位置的元素进行比较，就能知道目标值是否有可能落在这个区间，否则目标值只可能在另一侧。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-xian&quot;&gt;实现&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;search&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;bsearch&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nums&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;offset&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = nums.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, offset, offset + len);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mid = len &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; nums[mid] == target {
&lt;&#x2F;span&gt;&lt;span&gt;            (offset + mid) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; len &amp;amp;&amp;amp; nums[mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &amp;lt;= nums[len - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; target &amp;gt;= nums[mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &amp;amp;&amp;amp; target &amp;lt;= nums[len - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bsearch&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;nums[mid+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..], target, offset + mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; mid &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bsearch&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;nums[..mid], target, offset)
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; mid &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp;&amp;amp; nums[mid - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &amp;gt;= nums[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; target &amp;gt;= nums[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &amp;amp;&amp;amp; target &amp;lt;= nums[mid - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bsearch&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;nums[..mid], target, offset)
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; len {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bsearch&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;nums[mid+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..], target, offset + mid + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bsearch&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;nums, target, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Longest Palindrome Substring</title>
        <published>2023-09-08T00:00:00+00:00</published>
        <updated>2023-09-08T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/longest-palindrome/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/longest-palindrome/</id>
        
        <content type="html">&lt;h1 id=&quot;how-to-find-the-longest-palindrome-substring&quot;&gt;How to Find the Longest Palindrome Substring&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;longest-palindromic-substring&#x2F;&quot;&gt;题目链接&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;曾经会的算法，因为太久没做算法题，已经忘了。在这里留一下笔记。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;po-su-de-zuo-fa&quot;&gt;朴素的做法&lt;&#x2F;h2&gt;
&lt;p&gt;对于一个回文字符串中心 S[c]，如果它的半径是 R ，必须满足&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;S[c - i] == S[c + i], 0 &amp;lt;= i &amp;lt;= R
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所以如果我们需要知道以字符串中的任何一个位置作为中心的回文串的最大长度，只需要利用扩散的方法，找到第一个不相等的位置，就能得到回文串的半径。如果要求一个字符串的最长回文子串，只需要求出每个位置为中心的回文串的半径，选取最大者即可。&lt;&#x2F;p&gt;
&lt;p&gt;不过，这种做法的时间复杂度为 O(n^2) 。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;li-yong-yi-jing-ji-suan-de-hui-wen-ban-jing&quot;&gt;利用已经计算的回文半径&lt;&#x2F;h2&gt;
&lt;p&gt;如果我们能够利用之前已经获得的回文半径，是否可以加速计算的过程。在回答这个问题前，我们先来观察一下回文串的性质。&lt;&#x2F;p&gt;
&lt;p&gt;对于一个回文串中心 S[c] ，如果它的回文半径为 R （ R &amp;gt; 0 ）&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;......A......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;比如上图所示的字符串，它的中心位置 c = 6 处的字符为 A ，回文半径为 6 。假设在中心的左侧子串中包含了一个更小的回文串&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;.ABA..A...B..
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;左侧的子串 ABA 是一个回文串，中心在 c = 2 处。由于回文串的性质可以得知，在原字符串的索引 10 处也应该有一个 B 。如果我们此时已经知道 c = 6 处的回文半径，现在需要计算 c = 10 处的回文半径，我们是否需要从回文半径 R = 0 开始进行扩散，逐个匹配字符？&lt;&#x2F;p&gt;
&lt;p&gt;注意到在第一节中提到的性质，距离回文中心相同距离的两侧的字符应该是相等的。这意味着在上面提到的例子中，回文中心 c = 10 处的回文半径至少是 1 —— 根据回文串的性质，这个字符串应该为 &lt;code&gt;.ABA..A..ABA.&lt;&#x2F;code&gt; ；同时回文半径最多只能为 1 —— 因为 c = 2 处的回文半径为 1 ，已经不能再扩散了。因此，当一个较大的回文串「完全」包含了当前的回文子串时，它的回文半径与它的关于回文中心的位置的回文半径相同。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zhong-xin-zai-liang-ge-zi-fu-zhi-jian&quot;&gt;中心在两个字符之间&lt;&#x2F;h2&gt;
&lt;p&gt;只要在原字符串的每两个字符之间插入一个相同的无关字符即可。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;te-shu-qing-kuang&quot;&gt;特殊情况&lt;&#x2F;h2&gt;
&lt;p&gt;现在来考虑这样一种情况：根据如上的算法，如果现在正在计算的回文中心的对称点的回文串左侧的索引与大回文串的左侧索引相同，像下面这种情况：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ABA.C.ABA
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这时我们还能保证以右侧 B 为中心的回文串的回文半径只能为 1 吗？显然不能。此时索引为 9 的位置已经超出了大回文串的范围，已经失去了之前的信息，我们只能确定回文半径的最小值为 1 ，而不能确定最大值，必须进行扩散来获取准确值。&lt;&#x2F;p&gt;
&lt;p&gt;那么如果对称点的回文半径超出了大回文串的范围呢？由于失去了大回文串的限制，我们不能保证超出范围的部分依旧满足回文的条件，只能截取在大回文串中的部分。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;A[BA.C.AB]?
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;比如上面这个例子，左侧 B 的回文半径为 1 ，但是不能保证右侧 ? 位置的字符为 A ，所以也只能从包含在大回文串的部分，也就是回文半径为 0 开始扩散。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-li-dai-ma&quot;&gt;示例代码&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;longest_palindrome&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span&gt;: String) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expand&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;center&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skip&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        assert!(center &amp;gt;= skip);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; left, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; right) = (center - skip, center + skip);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; left &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp;&amp;amp; right &amp;lt; len - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp;&amp;amp; s[left - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] == s[right + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;                left -= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                right += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break &lt;&#x2F;span&gt;&lt;span&gt;(right - left) &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ns: String = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chars&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span&gt;(s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chars&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;flat_map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| [c, &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;]))
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = ns.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; radius = vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; len];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; center = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; center with max right bound
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; right = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; max right bound = center + radius[center]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; ans_pos, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; ans_radius) = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..len {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; arm = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; i &amp;gt; right {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expand&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;ns, i, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; i_sym = center - (i - center);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; skip = radius[i_sym].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(right - i);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expand&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;ns, i, skip)
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        radius[i] = arm;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; right &amp;lt; i + arm {
&lt;&#x2F;span&gt;&lt;span&gt;            center = i;
&lt;&#x2F;span&gt;&lt;span&gt;            right = i + arm;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; arm &amp;gt; ans_radius {
&lt;&#x2F;span&gt;&lt;span&gt;            ans_pos = i;
&lt;&#x2F;span&gt;&lt;span&gt;            ans_radius = arm;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ns[(ans_pos - ans_radius)..(ans_pos + ans_radius + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chars&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;filter&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| c != &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Call a Closure, RECURSIVEly?</title>
        <published>2023-09-04T00:00:00+00:00</published>
        <updated>2023-09-04T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/y-combinator/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/y-combinator/</id>
        
        <content type="html">&lt;h1 id=&quot;call-a-closure-recursively&quot;&gt;Call a Closure, RECURSIVEly?&lt;&#x2F;h1&gt;
&lt;p&gt;如果你需要递归调用一个函数，你会怎么做？这还不简单，直接在函数体内调用自己不就行了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;# rust
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;factorial&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; i &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        n * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;factorial&lt;&#x2F;span&gt;&lt;span&gt;(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;# lisp
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fact &lt;&#x2F;span&gt;&lt;span&gt;n)
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;          (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n (fact (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))))))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (fact &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;120
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是如果我们不使用 &lt;code&gt;define&lt;&#x2F;code&gt; ，只用闭包来定义这个函数，这种做法是否会出现问题呢？&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n (??? (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当需要递归调用时，我们惊喜地发现，我们无法找到这个函数的名字，也就无从调用。而 Lambda 演算和图灵机是等价的，实际上是可以找到一种方法递归调用的（当然，实际的逻辑关系正好相反，正是因为 Lambda 演算拥有递归的能力才能够图灵等价）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hui-diao-han-shu&quot;&gt;回调函数？&lt;&#x2F;h2&gt;
&lt;p&gt;我们很容易想到一个最简单的方法：既然我们在闭包内无法获得这个闭包的名字，那么我们就给这个闭包添加一个参数，接受一个函数。只要这个参数的实参是闭包本身，就可以用这个参数的名字替代闭包，做到递归调用的效果。我们先从 Lisp 入手。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;&amp;gt; ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n callback)
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;           (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n (callback (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) callback)))))
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5
&lt;&#x2F;span&gt;&lt;span&gt;   (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n callback)
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;           (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n (callback (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) callback))))))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;120
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，为了递归调用，我们添加了 &lt;code&gt;callback&lt;&#x2F;code&gt; 参数，最后将闭包自身作为 &lt;code&gt;callback&lt;&#x2F;code&gt; 参数进行调用。调用这个函数需要使用类似这样的形式：&lt;code&gt;(fact n fact)&lt;&#x2F;code&gt; 。如果需要不止一个参数（阶乘只需要一个 n ），我们可以将 &lt;code&gt;callback&lt;&#x2F;code&gt; 的参数顺序调整到第一个，同时进行柯里化，就能得到这样的形式： &lt;code&gt;((fn fn) args ...)&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;&amp;gt; (((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(fact)
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n)
&lt;&#x2F;span&gt;&lt;span&gt;       (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;             (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n ((fact fact) (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)))))))
&lt;&#x2F;span&gt;&lt;span&gt;   (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(fact)
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n)
&lt;&#x2F;span&gt;&lt;span&gt;       (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;             (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n ((fact fact) (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))))))))
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;120
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于这种形式 &lt;code&gt;(fn fn)&lt;&#x2F;code&gt; ，我们可以使用 ω 组合子来简化一下。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;# 虽然这里用了 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;, 但是可以当作是宏的定义
&lt;&#x2F;span&gt;&lt;span&gt;# omega = λf . f f
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;omega
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(f)
&lt;&#x2F;span&gt;&lt;span&gt;      (f f)))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; ((omega (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(fact) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n)
&lt;&#x2F;span&gt;&lt;span&gt;                           (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                                 (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n ((omega fact) (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))))))))
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;120
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ω 组合子的作用就是将闭包本身作为闭包的第一个参数。这样我们就能在闭包中调用到闭包自己了。&lt;&#x2F;p&gt;
&lt;p&gt;具体来说，如果我们拥有一个变量 &lt;code&gt;w: w -&amp;gt; a&lt;&#x2F;code&gt; ，它接受与自己类型相同的变量作为第一个参数，我们将其传入 ω 组合子，我们就可以通过 &lt;code&gt;(w w)&lt;&#x2F;code&gt; 得到一个 &lt;code&gt;a&lt;&#x2F;code&gt; ，同时，整个 ω 组合子表达式的结果也是 &lt;code&gt;a&lt;&#x2F;code&gt; 。得益于 ω 组合子，我们获得了给闭包起名字的能力（通过第一个参数）。&lt;&#x2F;p&gt;
&lt;p&gt;对于 Rust ，我们似乎也可以用同样的方法来解决这个问题。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fact &lt;&#x2F;span&gt;&lt;span&gt;= |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fact&lt;&#x2F;span&gt;&lt;span&gt;: ???, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; n &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        n * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fact&lt;&#x2F;span&gt;&lt;span&gt;(fact, n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里需要解决一个问题，闭包的参数中， &lt;code&gt;fact&lt;&#x2F;code&gt; 的实际类型是什么？ &lt;code&gt;fact&lt;&#x2F;code&gt; 的实际类型是 &lt;code&gt;Self&lt;&#x2F;code&gt; ，其中 &lt;code&gt;Self: Fn(Self, i32) -&amp;gt; i32&lt;&#x2F;code&gt; 。我们可以发现，这实际上一个递归类型，这个递归类型让这个闭包可以无限递归，但是 Rust 无法接受这样一个可以无限递归的类型。因此，我们需要把这个闭包用 &lt;code&gt;Struct&lt;&#x2F;code&gt; 包裹起来，使用它提供的 &lt;code&gt;Self&lt;&#x2F;code&gt; 类型。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Wrapper&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, I, O&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;closure&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; dyn Fn(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;, I) -&amp;gt; O,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, I, O&amp;gt; Wrapper&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, I, O&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;closure&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; dyn Fn(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; O) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ closure }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;: I) -&amp;gt; O {
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.closure)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, i)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; fact = Wrapper::new(&amp;amp;|fact: &amp;amp;Wrapper&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, n| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; n &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            n * fact.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fact(5) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, fact.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; fact(5) = 120
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;Wrapper::call&lt;&#x2F;code&gt; 其实就是 ω 组合子，我们就不需要写 &lt;code&gt;fact.closure(&amp;amp;fact, n)&lt;&#x2F;code&gt; 了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;geng-jian-ji-de-xing-shi&quot;&gt;更简洁的形式&lt;&#x2F;h2&gt;
&lt;p&gt;虽然我们已经实现了在闭包中递归调用，不过，每次调用都需要使用 ω 组合子或者把函数名写两遍，显得很累赘，形式不够优美(对于 Rust ，我们可以使用 Fn traits 来简化书写方式，以下不讨论)。为了简洁，我们需要将找到一个新的组合子，满足下面的条件：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;((new-combinator f&amp;#39;) n) = ((omega f) n)
&lt;&#x2F;span&gt;&lt;span&gt;其中
&lt;&#x2F;span&gt;&lt;span&gt;f: (f -&amp;gt; a -&amp;gt; b) -&amp;gt; a -&amp;gt; b
&lt;&#x2F;span&gt;&lt;span&gt;f&amp;#39;: f&amp;#39;&amp;#39; -&amp;gt; a -&amp;gt; b
&lt;&#x2F;span&gt;&lt;span&gt;f&amp;#39;&amp;#39;: a -&amp;gt; b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个新的组合子与 ω 组合子的不同点在于， &lt;code&gt;f&#x27;&#x27;&lt;&#x2F;code&gt; 不再需要一个函数作为参数，我们可以直接将 &lt;code&gt;a&lt;&#x2F;code&gt; 作为它的参数来调用，&lt;code&gt;(f&#x27;&#x27; a) = b&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;我们先写出这个新组合子的参数部分：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(f)
&lt;&#x2F;span&gt;&lt;span&gt;  (wrap f))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们现在还不能知道如何实现 &lt;code&gt;wrap&lt;&#x2F;code&gt; 。但可以确定的一点是 &lt;code&gt;(wrap ...)&lt;&#x2F;code&gt; 的结果是一个 &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; ，我们可以从 &lt;code&gt;new-combinator&lt;&#x2F;code&gt; 的签名得知。既然 &lt;code&gt;(wrap ...)&lt;&#x2F;code&gt; 的结果可以直接作为 &lt;code&gt;f&#x27;&#x27;&lt;&#x2F;code&gt; ，我们不妨对这一点加以利用，使用 ω 组合子，让这个结果在 &lt;code&gt;wrap&lt;&#x2F;code&gt; 内部可用。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(f)
&lt;&#x2F;span&gt;&lt;span&gt;  (omega (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(g)
&lt;&#x2F;span&gt;&lt;span&gt;    (f (g g)))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;基于 ω 组合子的性质，我们可以通过 &lt;code&gt;(g g)&lt;&#x2F;code&gt; 获取这个闭包的结果（ &lt;code&gt;g&lt;&#x2F;code&gt; 实际上只有一个参数），也就是我们需要的 &lt;code&gt;f&#x27;&#x27;&lt;&#x2F;code&gt;。不过，现在的组合子我们不能直接用在部分代码中——对于严格求值的语言，在调用函数前，需要先计算出 &lt;code&gt;(g g)&lt;&#x2F;code&gt; 的值，这是一个无限递归的过程。我们需要一个延迟计算的方式。在 &lt;code&gt;Racket&lt;&#x2F;code&gt; 中有两种方法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Lazy Lambda ，将参数求值延迟到实际使用参数的时候。对于这种方式，直接上面的定义就行了。&lt;&#x2F;li&gt;
&lt;li&gt;在用一个 Lambda 包裹住 &lt;code&gt;(g g)&lt;&#x2F;code&gt; 的求值部分。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;对于第二种方式，实现如下。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;Y
&lt;&#x2F;span&gt;&lt;span&gt;  (λ (f)
&lt;&#x2F;span&gt;&lt;span&gt;    (ω (λ (g)
&lt;&#x2F;span&gt;&lt;span&gt;         (f (λ (x) ((g g) x)))))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里用一个 &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; 闭包包裹住了 &lt;code&gt;(g g)&lt;&#x2F;code&gt; ，这样，只有在传递一个 &lt;code&gt;a&lt;&#x2F;code&gt; 时才会触发 &lt;code&gt;(g g)&lt;&#x2F;code&gt; 的求值。这就是大名鼎鼎的 Y 组合子，它赋予了 Lambda 演算递归的能力，是一个非常强大的组合子。某些 Lisp 方言利用它实现了函数定义，&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jarcane&#x2F;heresy&#x2F;blob&#x2F;master&#x2F;lib&#x2F;theory.rkt&quot;&gt;比如这门 Heresy 方言&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以试试 Y 组合子的威力。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;ω
&lt;&#x2F;span&gt;&lt;span&gt;    (λ (f)
&lt;&#x2F;span&gt;&lt;span&gt;      (f f)))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;Y
&lt;&#x2F;span&gt;&lt;span&gt;    (λ (target)
&lt;&#x2F;span&gt;&lt;span&gt;      (ω (λ (f)
&lt;&#x2F;span&gt;&lt;span&gt;           (target (λ (x) ((ω f) x)))))))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;factorial
&lt;&#x2F;span&gt;&lt;span&gt;    (Y (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(factorial)
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(n)
&lt;&#x2F;span&gt;&lt;span&gt;           (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond &lt;&#x2F;span&gt;&lt;span&gt;((&amp;lt;= n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                 (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;(* n (factorial (- n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)))))))))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (factorial &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;120&lt;&#x2F;span&gt;&lt;span&gt; # TADAA!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Y 组合子的形式定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ω = λf . f f
&lt;&#x2F;span&gt;&lt;span&gt;Y = λ f . ω (λ g . f (ω g))
&lt;&#x2F;span&gt;&lt;span&gt;  = λ f . (λ g . f (g g)) (λ g . f (g g))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>复古EMail配置</title>
        <published>2023-04-10T00:00:00+00:00</published>
        <updated>2023-04-10T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/mail-config/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/mail-config/</id>
        
        <content type="html">&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Thunderbird 曾经是我的主力邮件客户端, 它支持非常多的功能, 包括 RSS ,
多种即时聊天( Matrix 也包括在其中), 还能与网络日历同步.
但是大部分功能我都用不上: 我只是需要一个简单的邮件客户端,
让我可以流畅地处理工作就行了. 这时Thunderbird丰富的功能反而成了累赘.&lt;&#x2F;p&gt;
&lt;p&gt;最后选择了 &lt;a href=&quot;https:&#x2F;&#x2F;mutt.org&#x2F;&quot;&gt;Mutt&lt;&#x2F;a&gt; 作为我的新邮件客户端(事实上, 在本篇
Post 写作的三个月前我就在使用 &lt;code&gt;Mutt&lt;&#x2F;code&gt; 了). 这是一个最早发行于 199X
年的基于文本的邮件客户端, 截止本篇 Post 写成, 已经更新到了 2.2.10 版本.
支持的特性包括:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;颜色支持&lt;&#x2F;li&gt;
&lt;li&gt;Threading&lt;&#x2F;li&gt;
&lt;li&gt;MIME Support&lt;&#x2F;li&gt;
&lt;li&gt;IMAP &#x2F; POP3 支持&lt;&#x2F;li&gt;
&lt;li&gt;高可定制&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这里所写的特性并不是 &lt;code&gt;Mutt&lt;&#x2F;code&gt; 的全部. 因为它的高可定制,
我们可以把它变成我们想要它成为的任何模样, 正如其开发者所说:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;All mail clients suck. This one just sucks less&amp;quot;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-yu-dian-zi-you-jian-de-jian-dan-jie-shao&quot;&gt;关于电子邮件的简单介绍&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;dang-wo-men-shi-yong-dian-zi-you-jian-shi-dao-di-fa-sheng-liao-shi-yao&quot;&gt;当我们使用电子邮件时, 到底发生了什么?&lt;&#x2F;h3&gt;
&lt;p&gt;假设我们的邮件地址是 &lt;code&gt;a@a.com&lt;&#x2F;code&gt; , 配置的 SMTP 服务器是 &lt;code&gt;smtp.a.com&lt;&#x2F;code&gt; ,
接收者的邮件地址是 &lt;code&gt;b@b.com&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用SMTP协议, 将邮件推送到我们的 SMTP 服务器上.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;smtp.a.com&lt;&#x2F;code&gt; 的 MTA 接收到邮件后
&lt;ul&gt;
&lt;li&gt;找到收件人的邮件服务器地址 &lt;code&gt;b.com&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;向 DNS 服务器查询 &lt;code&gt;b.com&lt;&#x2F;code&gt; 的 MX 记录, 得到 &lt;code&gt;mail.b.com&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;向 DNS 服务器查询 &lt;code&gt;mail.b.com&lt;&#x2F;code&gt; 的 IP 地址, 得到 &lt;code&gt;1.2.3.4&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;向该 IP 地址使用 SMTP 协议发送邮件&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;接收者的邮件服务器收到邮件, 确认收件人在当前服务器上后, 使用 MDA
投放邮件(可能是对应用户的文件夹, 也有可能是数据库)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这个时候, 邮件仍然在服务器上, 接收者可以登录邮件服务器查看邮件,
比如ssh登录查看, 或者登录邮件服务商提供的网页接口. 当然,
我们还有另外一个选择: 将邮件下载下来. 有两个协议可以实现这个目的, IMAP
和 POP3 . 下面是两个协议间的简单对比:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;POP3&lt;&#x2F;th&gt;&lt;th&gt;IMAP&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;同时只能有一个客户端访问&lt;&#x2F;td&gt;&lt;td&gt;可以有多个客户端访问&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;单向传输&lt;&#x2F;td&gt;&lt;td&gt;双向传输&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;快&lt;&#x2F;td&gt;&lt;td&gt;相对 POP3 更慢&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;删除模式和保留模式. 区别在于收取邮件后是否删除服务器上的备份&lt;&#x2F;td&gt;&lt;td&gt;收取后还能保留副本&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;一次需要收取所有邮件&lt;&#x2F;td&gt;&lt;td&gt;在下载前可以查看邮件头决定是否下载&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;you-jian-ke-hu-duan-de-jia-gou&quot;&gt;邮件客户端的架构&lt;&#x2F;h3&gt;
&lt;p&gt;我们的邮件客户端的架构如下:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;MUA: mutt , 用于查看邮件. 虽然 mutt 拥有 IMAP 和 POP3 支持,
但是使用起来不算方便, 我们将要用其他的软件来实现这些功能.&lt;&#x2F;li&gt;
&lt;li&gt;MRA: fetchmail , 用于从服务器收取邮件, 实现 IMAP 和 POP3 的功能.
fetchmail 也可以看作一个特殊的 MTA : 它将邮件收取后, 也会将邮件输出给
MDA 进行投送. 由大名鼎鼎的 Raymond 开发.&lt;&#x2F;li&gt;
&lt;li&gt;MDA: procmail , 投送邮件. 根据邮件的内容投送到对应的地方.&lt;&#x2F;li&gt;
&lt;li&gt;smtp: msmtp , 发送邮件.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;处理邮件的流程就是由 fetchmail 从邮件服务器收取邮件, 将邮件通过 stdin
输入给 procmail 投递到对应的文件夹. 使用 mutt 访问邮件文件夹.
需要发送邮件时, 通过 mutt 调用编辑器 (比如 neovim &#x2F; vim &#x2F; nano)
进行邮件内容编辑, 再调用 msmtp 发送到 SMTP 服务器.
在发送邮件和阅读邮件时, 也可以使用 gpg 来对邮件进行签名加密 &#x2F; 验证解密.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fetchmail-procmail&quot;&gt;fetchmail &amp;amp; procmail&lt;&#x2F;h2&gt;
&lt;p&gt;fetchmail 负责收取邮件, 相关的配置在 &lt;code&gt;$HOME&#x2F;.fetchmailrc&lt;&#x2F;code&gt; ,
我们可以在配置文件中指定我们需要收取的邮件地址.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;poll pop.AAA.com protocol POP3 user &amp;quot;me@AAA.com&amp;quot; password &amp;quot;123&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;poll pop.BBB.com protocol POP3 user &amp;quot;me&amp;quot; there with password &amp;quot;123&amp;quot; is falko here fetchall
&lt;&#x2F;span&gt;&lt;span&gt;poll pop.CCC.com protocol POP3 user &amp;quot;me&amp;quot; there with password &amp;quot;123&amp;quot; is till here keep
&lt;&#x2F;span&gt;&lt;span&gt;poll pop.DDD.com
&lt;&#x2F;span&gt;&lt;span&gt;  protocol POP3
&lt;&#x2F;span&gt;&lt;span&gt;  user &amp;quot;me&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  password &amp;quot;123&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# 全局选项
&lt;&#x2F;span&gt;&lt;span&gt;mimedecode
&lt;&#x2F;span&gt;&lt;span&gt;mda &amp;quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;procmail&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;poll &amp;lt;ADDRESS&amp;gt;&lt;br &#x2F;&gt;
指定一个需要收取的账户&lt;&#x2F;p&gt;
&lt;p&gt;protocol POP3 | IMAP&lt;br &#x2F;&gt;
指定使用的协议&lt;&#x2F;p&gt;
&lt;p&gt;user &amp;lt;USERNAME&amp;gt;&lt;br &#x2F;&gt;
指定用户名, 或者邮件地址&lt;&#x2F;p&gt;
&lt;p&gt;password &amp;lt;PASSWORD&amp;gt;&lt;br &#x2F;&gt;
账户密码&lt;&#x2F;p&gt;
&lt;p&gt;&amp;lt;OPTION&amp;gt; ..&lt;br &#x2F;&gt;
包括 fetchall, nofetchall, keep, nokeep 等等&lt;&#x2F;p&gt;
&lt;p&gt;mimedecode&lt;br &#x2F;&gt;
自动解码 mime&lt;&#x2F;p&gt;
&lt;p&gt;mda &amp;lt;PATH&amp;gt;&lt;br &#x2F;&gt;
指定 mda 程序的路径, 这里我们使用 procmail&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 收取未读邮件
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fetchmail
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 收取所有邮件
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fetchmail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -a
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 收取未读邮件, 但是不删除服务器上已经收取的邮件
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fetchmail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -k
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 设置超时时间(s)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fetchmail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -t&lt;&#x2F;span&gt;&lt;span&gt; 60
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;每一次执行上述命令都会收取所有的邮件并交由 mda 处理,
并不会在后台自动收件, 所以我们需要手动执行命令 &#x2F; Cron 定期任务.&lt;&#x2F;p&gt;
&lt;p&gt;procmail 的配置在 &lt;code&gt;$HOME&#x2F;.procmailrc&lt;&#x2F;code&gt; ,
其中定义了收取到的邮件的处理规则, 使用正则表达式定义.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;MAILDIR=$HOME&#x2F;Mail   #邮件存储地址
&lt;&#x2F;span&gt;&lt;span&gt;DEFAULT=$MAILDIR&#x2F;inbox   #默认：收件箱
&lt;&#x2F;span&gt;&lt;span&gt;VERBOSE=off
&lt;&#x2F;span&gt;&lt;span&gt;LOGFILE=&#x2F;tmp&#x2F;procmaillog
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# 某个垃圾邮件规则
&lt;&#x2F;span&gt;&lt;span&gt;:0
&lt;&#x2F;span&gt;&lt;span&gt;* ^From: spam@aaa\.com
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;null    #垃圾文件的存储位置
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# 其它所有都存到收件箱中
&lt;&#x2F;span&gt;&lt;span&gt;:0:
&lt;&#x2F;span&gt;&lt;span&gt;inbox&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;完成配置后, 我们使用 fetchmail
收件后就能在收件箱路径下找到我们的新邮件了.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;msmtp&quot;&gt;msmtp&lt;&#x2F;h2&gt;
&lt;p&gt;msmtp 的配置就很简单了,
基本上就是将平常我们使用邮件客户端时需要填写的配置内容以文本的形式填写到配置文件中.
msmtp 的配置文件路径为 &lt;code&gt;$HOME&#x2F;.msmtprc&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;acount default
&lt;&#x2F;span&gt;&lt;span&gt;auth login
&lt;&#x2F;span&gt;&lt;span&gt;host smtp.XXX.com
&lt;&#x2F;span&gt;&lt;span&gt;port 587
&lt;&#x2F;span&gt;&lt;span&gt;from ME@XXX.com
&lt;&#x2F;span&gt;&lt;span&gt;user ME
&lt;&#x2F;span&gt;&lt;span&gt;password passwd
&lt;&#x2F;span&gt;&lt;span&gt;tls on
&lt;&#x2F;span&gt;&lt;span&gt;tls_certcheck off
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;logfile &#x2F;tmp&#x2F;msmtp.logrc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果需要多账户, 我们只需要定义多个 account &amp;lt;ACCOUNT&amp;gt; , 在调用 msmtp
时添加参数 ~ -a &amp;lt;ACCOUNT&amp;gt; ~ 即可.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mutt&quot;&gt;mutt&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;# 通用设定
&lt;&#x2F;span&gt;&lt;span&gt;set use_from=yes
&lt;&#x2F;span&gt;&lt;span&gt;set envelope_from=yes
&lt;&#x2F;span&gt;&lt;span&gt;set move=yes    #移动已读邮件
&lt;&#x2F;span&gt;&lt;span&gt;set include #回复的时候调用原文
&lt;&#x2F;span&gt;&lt;span&gt;set charset=&amp;quot;utf-8&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# 发送者账号
&lt;&#x2F;span&gt;&lt;span&gt;set realname=&amp;quot;Phillips Horselover&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;set from=&amp;quot;phillips@navihx.top&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# 分类邮箱
&lt;&#x2F;span&gt;&lt;span&gt;set mbox_type = Maildir #Mail box type
&lt;&#x2F;span&gt;&lt;span&gt;set folder = &amp;quot;$HOME&#x2F;Mail&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;set spoolfile = &amp;quot;$HOME&#x2F;Mail&#x2F;inbox&amp;quot; #INBOX
&lt;&#x2F;span&gt;&lt;span&gt;set mbox=&amp;quot;$HOME&#x2F;Mail&#x2F;seen&amp;quot;  #Seen box
&lt;&#x2F;span&gt;&lt;span&gt;set record=&amp;quot;$HOME&#x2F;Mail&#x2F;sent&amp;quot;  #Sent box
&lt;&#x2F;span&gt;&lt;span&gt;set postponed=&amp;quot;$HOME&#x2F;Mail&#x2F;draft&amp;quot;  #Draft box
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;set editor=&amp;quot;vim -nw&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;set sendmail=&amp;quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;msmtp&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;以上的配置对于只需要一个账户的使用者已经足够了.
但是如果你需要使用很多个邮件账户, 每个账户中都有不同的配置, 可以使用
mutt 提供的 folder hooker 功能: 当 mutt 进入某个邮件文件夹时,
重新读入一段配置来覆盖原本的配置.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;folder-hook &amp;#39;INBOX&amp;#39; &amp;#39;source ~&#x2F;.config&#x2F;mutt&#x2F;accounts&#x2F;default&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;folder-hook &amp;#39;gmail&amp;#39; &amp;#39;source ~&#x2F;.config&#x2F;mutt&#x2F;accounts&#x2F;gmail&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;folder-hook &amp;#39;personal&amp;#39; &amp;#39;source ~&#x2F;.config&#x2F;mutt&#x2F;accounts&#x2F;personal&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;folder-hook &amp;#39;phillips&amp;#39; &amp;#39;source ~&#x2F;.config&#x2F;mutt&#x2F;accounts&#x2F;phillips&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;qi-ta&quot;&gt;其他&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;shi-yong-gpg-jia-mi-qian-ming-you-jian&quot;&gt;使用 GPG 加密 &#x2F; 签名邮件&lt;&#x2F;h3&gt;
&lt;p&gt;在 muttrc 中添加 &lt;code&gt;source $HOME&#x2F;.mutt&#x2F;gpg.rc&lt;&#x2F;code&gt; , 在对应文件中写入 gpg
的设置. 示例配置在 &lt;code&gt;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;mutt&#x2F;smaples&#x2F;gpg.rc&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bao-hu-ni-de-mi-ma&quot;&gt;保护你的密码&lt;&#x2F;h3&gt;
&lt;p&gt;我们在上面的配置中全部写了明文的密码, 这是非常不安全的,
即使我们可以将配置文件的权限设置为 &lt;code&gt;700&lt;&#x2F;code&gt; 或者更低. 我们依然可以使用 gpg
来对我们的密码进行加密.&lt;&#x2F;p&gt;
&lt;p&gt;msmtp 可以使用 passwordeval &amp;lt;COMMAND&amp;gt; 代替 password &amp;lt;PASSWORD&amp;gt; ,
它执行一条指令, 将指令的输出作为密码. 我们可以这样写
&lt;code&gt;passwordeval  &amp;quot;gpg --quiet --for-your-eyes-only --no-tty --decrypt $HOME&#x2F;mail&#x2F;.msmtp-credentials.gpg&amp;quot;&lt;&#x2F;code&gt;
.&lt;&#x2F;p&gt;
&lt;p&gt;mutt 可以将我们密码的设置放到一个单独文件中, 对其加密, 然后在 mutt
配置中先对其解密在执行. 比如我们这样设置了密码:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;# .my-passwordrc
&lt;&#x2F;span&gt;&lt;span&gt;set my_pass = &amp;quot;password&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们对其加密得到一个新文件 .my-passwordrc.gpg . 在 mutt 配置文件中新增:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;source &amp;quot;gpg -dq $HOME&#x2F;.my-passwordrc.gpg |&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Why is this async block `FnOnce`</title>
        <published>2023-03-16T00:00:00+00:00</published>
        <updated>2023-03-16T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/async-block/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/async-block/</id>
        
        <content type="html">&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h1&gt;
&lt;p&gt;写这篇post的原因是, 在给机器人写 warp server 的代码时,
遇到了下面这个编译错误:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    warp::path!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;select&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &#x2F; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;coordinate&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt;(warp::post())
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt;(warp::body::content_length_limit(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt;(warp::body::json())
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;then&lt;&#x2F;span&gt;&lt;span&gt;(|SelectCoordinate{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;, y}: SelectCoordinate| async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Err(_) = update_sender.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(UpdateMessage::Update(StateUpdate::AddNewRouteByCoordinate(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;::robot::Coordinate(x, y)))).await {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;return_code&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;return_code&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;E0525&lt;&#x2F;span&gt;&lt;span&gt;]: expected a closure that implements the `Fn` &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;trait&lt;&#x2F;span&gt;&lt;span&gt;, but this closure only implements `FnOnce`
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; robot_admin&#x2F;src&#x2F;route.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;92&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;92 &lt;&#x2F;span&gt;&lt;span&gt;|         .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;then&lt;&#x2F;span&gt;&lt;span&gt;(|SelectCoordinate{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;, y}: SelectCoordinate| async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   |          ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this closure implements `FnOnce`, not `Fn`
&lt;&#x2F;span&gt;&lt;span&gt;   |          |
&lt;&#x2F;span&gt;&lt;span&gt;   |          the requirement to implement `Fn` derives from here
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;93 &lt;&#x2F;span&gt;&lt;span&gt;|                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Err(_) = update_sender.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(UpdateMessage::Update(StateUpdate::AddNewRouteByCoordinate(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;:...
&lt;&#x2F;span&gt;&lt;span&gt;   |                                 ------------- closure is `FnOnce` because it moves the variable `update_sender` out of 
&lt;&#x2F;span&gt;&lt;span&gt;its environment
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = note: required &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; `[closure@robot_admin&#x2F;src&#x2F;route.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;92&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;92&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;57&lt;&#x2F;span&gt;&lt;span&gt;]` to implement `warp::generic::Func&amp;lt;(SelectCoordinat
&lt;&#x2F;span&gt;&lt;span&gt;e,)&amp;gt;`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;For more information about this error, try `rustc --explain &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;E0525&lt;&#x2F;span&gt;&lt;span&gt;`.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段代码生成一个 &lt;code&gt;POST &#x2F;select&#x2F;coordinate&lt;&#x2F;code&gt; 的路由, 它接收一个json
form并更新机器人的路径信息. 这个更新的工作交由一个 &amp;quot;异步闭包&amp;quot; 来完成.&lt;&#x2F;p&gt;
&lt;p&gt;我并 &amp;quot; 没有将 &lt;code&gt;update_sender&lt;&#x2F;code&gt; 消耗或者移动所有权 &amp;quot;, 但是这个闭包却是
&lt;code&gt;FnOnce&lt;&#x2F;code&gt; 而不是 &lt;code&gt;Fn&lt;&#x2F;code&gt; , 不符合要求, 编译失败.
这种情况可以简化成下面的代码:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::future::Future;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Debug, Clone)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;S { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take_fn&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Future&amp;lt;Output = ()&amp;gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_f&lt;&#x2F;span&gt;&lt;span&gt;: impl Fn() -&amp;gt; T) -&amp;gt; () {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take_fnonce&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Future&amp;lt;Output = ()&amp;gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_f&lt;&#x2F;span&gt;&lt;span&gt;: impl FnOnce() -&amp;gt; T) -&amp;gt; () {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; TODO Why is `f` a `FnOnce`, which means that `f` takes the ownership of s and consumes it.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = S { a: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span&gt;= || async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, s);
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take_fn&lt;&#x2F;span&gt;&lt;span&gt;(f);     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ERROR!
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take_fnonce&lt;&#x2F;span&gt;&lt;span&gt;(f); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; OK!
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Hello world!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=3029d58d12f93f8a744481a5b6c1aa9e&quot;&gt;这个Playground可以直接尝试&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;f-shi-yi-ge-yi-bu-bi-bao-ma&quot;&gt;&lt;code&gt;f&lt;&#x2F;code&gt; 是一个异步闭包吗?&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;rust&lt;&#x2F;code&gt; 的异步闭包的语法是 &lt;code&gt;async [move] |_| { &#x2F;* block *&#x2F; }&lt;&#x2F;code&gt; .
但是注意看 &lt;code&gt;f&lt;&#x2F;code&gt; 的声明, &lt;code&gt;async move&lt;&#x2F;code&gt; 写在了参数的后面,
说明这不是一个异步闭包, 而只是一个普通的闭包, 它返回一个 &lt;code&gt;impl Future&lt;&#x2F;code&gt; .
&lt;code&gt;take_fn*&lt;&#x2F;code&gt; 的签名也证明了这一点.&lt;&#x2F;p&gt;
&lt;p&gt;异步闭包&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;62290&quot;&gt;现在是一个不稳定的特性&lt;&#x2F;a&gt;,
一般都通过一个返回 &lt;code&gt;Future&lt;&#x2F;code&gt; &#x2F; 异步 block 的普通闭包实现. &lt;code&gt;FnOnce&lt;&#x2F;code&gt;
说明了我们写的这个 闭包确实消耗了所有权, 只能执行一次 (对比 &lt;code&gt;Fn&lt;&#x2F;code&gt; ,
它并不消耗所有权, 所以可以执行任意多次).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wei-shi-yao-shi-fnonce&quot;&gt;为什么是 &lt;code&gt;FnOnce&lt;&#x2F;code&gt; ?&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;f&lt;&#x2F;code&gt; 返回的异步 block 是 move 块, 说明这个块会获得捕获变量的所有权.
包裹这个异步块的闭包捕获了 &lt;code&gt;s&lt;&#x2F;code&gt;, 随后又被异步块获取了 所有权.
异步块作为返回值, 将 &lt;code&gt;s&lt;&#x2F;code&gt; 的所有权转移到了外部, 这个时候闭包已经不拥有
&lt;code&gt;s&lt;&#x2F;code&gt; 的所有权了, 所以为 &lt;code&gt;FnOnce&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;p&gt;所有权的转移过程也可以像下面这样展示:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span&gt;= || {                      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Closure 从环境中捕获了 s
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Async Block 使用 move 捕获, 直接获取所有权而不是借用
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, s); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Async Block 从 Closure 中捕获了 s
&lt;&#x2F;span&gt;&lt;span&gt;    }                             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Async Block 结束
&lt;&#x2F;span&gt;&lt;span&gt;};                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; s 的所有权和 Async Block 作为返回值一同转移到了外部
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;解决的办法就是在闭包中保留所有权, 比如说直接 &lt;code&gt;Clone(&amp;amp;self)&lt;&#x2F;code&gt; 或者使用
&lt;code&gt;Arc&lt;&#x2F;code&gt; 来进行管理.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = S { a: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; f = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;|| {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, s);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take_fn&lt;&#x2F;span&gt;&lt;span&gt;(f); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; TADAA!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Brainf*cking with Racket</title>
        <published>2023-02-08T00:00:00+00:00</published>
        <updated>2023-02-08T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/brainfuck-in-racket/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/brainfuck-in-racket/</id>
        
        <content type="html">&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h1&gt;
&lt;p&gt;Racket 等 Lisp 家族的语言拥有强大的宏, 可以让我们很方便地对语言进行扩展,
但是使用宏却带来了两点限制:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;宏不能限制它的上下文和改变上下文的含义.
宏的设计者无法阻止使用者在任何地方使用宏, 这可能会造成预想不到的后果.&lt;&#x2F;li&gt;
&lt;li&gt;宏使用的词法必须遵守原语言的词法规则.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;使用宏对语言进行的改造是十分有限的. 如果需要对语言进行深层次的定制,
仅仅使用宏就有点力不从心了. 本文将从 brainfuck 出发, 使用 racket
创造出一门基于 racket 的语言, 同时也是我最近这段时间学习 racket 的总结.&lt;&#x2F;p&gt;
&lt;p&gt;目标是成功运行以下代码:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;#lang bf
&lt;&#x2F;span&gt;&lt;span&gt;++++++[&amp;gt;++++++++++++&amp;lt;-]&amp;gt;.
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;++++++++++[&amp;gt;++++++++++&amp;lt;-]&amp;gt;+.
&lt;&#x2F;span&gt;&lt;span&gt;+++++++..+++.&amp;gt;++++[&amp;gt;+++++++++++&amp;lt;-]&amp;gt;.
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;+++[&amp;gt;----&amp;lt;-]&amp;gt;.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;+++[&amp;gt;+++++&amp;lt;-]&amp;gt;.
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;.+++.------.--------.&amp;gt;&amp;gt;+.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;racket-guan-yu-yu-fa-de-ji-chu-she-shi&quot;&gt;Racket 关于语法的基础设施&lt;&#x2F;h1&gt;
&lt;p&gt;为了定制我们的 brainfuck , 我们需要了解 Racket 本身提供的设施.
在我们编写 racket 源文件时, 总会像这样写:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;#lang racket
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; our code begins ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;开头的 &lt;code&gt;#lang racket&lt;&#x2F;code&gt; 指明了这个源文件使用的语言, 这种特性被称为 module
language. 这个其实是 racket module 的一个 shorthand. 展开为完整形式如下:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;file_name&amp;gt; racket
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; our code begins ...)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;module&lt;&#x2F;code&gt; 中的 &lt;code&gt;racket&lt;&#x2F;code&gt; 其实就是最开始导入的包名(即所谓 &lt;code&gt;init module&lt;&#x2F;code&gt; ).
这提供了一种控制语法的方法. 比如说可以为我们定制的语言提供一个
&lt;code&gt;function&lt;&#x2F;code&gt; 关键字:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;raquet racket
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;provide &lt;&#x2F;span&gt;&lt;span&gt;(except-out (all-from-out racket) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; 导出racket中除了lambda外的内容
&lt;&#x2F;span&gt;&lt;span&gt;       (rename-out [lambda function]))) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; 将lambda作为function导出
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;src-file &amp;#39;raquet &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; 可以理解为 #lang raquet
&lt;&#x2F;span&gt;&lt;span&gt;    (map (function (points) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;points
&lt;&#x2F;span&gt;&lt;span&gt;                             [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;love&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;fifteen&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                             [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;thirty&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;forty&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]))
&lt;&#x2F;span&gt;&lt;span&gt;         &amp;#39;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;src-file)
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;love&amp;quot; &amp;quot;thirty&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样, 我们就可以用 &lt;code&gt;function&lt;&#x2F;code&gt; 创建一个函数, 而不是使用 &lt;code&gt;lambda&lt;&#x2F;code&gt; .
作为module language导入的包与普通的包又略有不同,
它还需要提供一些额外的项目:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#%module-begin&lt;&#x2F;code&gt;, 包裹了模块代码的隐式语句. 后面会用到.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;#%app&lt;&#x2F;code&gt;, 调用一个过程, &lt;code&gt;(func arg1 arg2)&lt;&#x2F;code&gt; 就是
&lt;code&gt;(#%app func arg1 arg2)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;#%top&lt;&#x2F;code&gt;, &lt;code&gt;(#%top . id)&lt;&#x2F;code&gt;, 返回顶层的变量, 如果有本地绑定则报错.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;#%datum&lt;&#x2F;code&gt;, 创建一个字面量.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些项目都可以在代码中显式地使用, 但它们最主要的用处还是为 module
language 提供了修改这些隐式调用的能力.
比如说在一门定制的lambda运算语言中限制函数只能有一个参数:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;lambda-calculus racket
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;provide &lt;&#x2F;span&gt;&lt;span&gt;(rename-out [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-arg-lambda lambda]
&lt;&#x2F;span&gt;&lt;span&gt;                       [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-arg-app #%app]
&lt;&#x2F;span&gt;&lt;span&gt;                       [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-form-module-begin #%module-begin]
&lt;&#x2F;span&gt;&lt;span&gt;                       [no-literals #%datum]
&lt;&#x2F;span&gt;&lt;span&gt;                       [unbound-as-quoted #%top]))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-arg-lambda (x) expr)
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x) expr))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-arg-app e1 e2)
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#%app &lt;&#x2F;span&gt;&lt;span&gt;e1 e2))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-form-module-begin e)
&lt;&#x2F;span&gt;&lt;span&gt;    (#%module-begin e))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax &lt;&#x2F;span&gt;&lt;span&gt;(no-literals stx)
&lt;&#x2F;span&gt;&lt;span&gt;    (raise-syntax-error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#f&lt;&#x2F;span&gt;&lt;span&gt; &amp;quot;no&amp;quot; stx))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(unbound-as-quoted . id)
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;id))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;ok &amp;#39;lambda-calculus
&lt;&#x2F;span&gt;&lt;span&gt;    ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x) (x z))
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(y) y)))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;ok)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;z
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;not-ok &amp;#39;lambda-calculus
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x y) x))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;eval:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;: lambda: use does &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span&gt;match pattern: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;expr)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  in: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x y) x)
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;not-ok &amp;#39;lambda-calculus
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x) x)
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(y) (y y)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;eval:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;: #%module-begin: use does &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span&gt;match pattern:
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(#%module-begin e)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  in: (#%module-begin (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x) x) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(y) (y y)))
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;not-ok &amp;#39;lambda-calculus
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(x) (x x x)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;eval:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;: #%app: use does &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span&gt;match pattern: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#%app &lt;&#x2F;span&gt;&lt;span&gt;e1 e2)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  in: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#%app &lt;&#x2F;span&gt;&lt;span&gt;x x x)
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;module &lt;&#x2F;span&gt;&lt;span&gt;not-ok &amp;#39;lambda-calculus
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;eval:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;: #%datum: no
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;in: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#%datum &lt;&#x2F;span&gt;&lt;span&gt;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的例子都重复导出了 Racket 的内容, 或者直接使用了 Racket,
并没有直接使用 &lt;code&gt;#lang xxx&lt;&#x2F;code&gt;. 一门完整的 module language, 还需要提供
reader 来解析源文件. 一份 Racket 源文件(或者其他由 Racket
定制而来的语言)的处理过程如下:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;surface syntax --|reader|-&amp;gt; AST --|macro expansion|--&amp;gt; coreforms
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另外, module language 还可以用 &lt;code&gt;read&lt;&#x2F;code&gt; , &lt;code&gt;read-syntax&lt;&#x2F;code&gt; 自定义解析器逻辑.
看上去完全实现一门 module language 是有些困难的. Racket 提供了 &lt;code&gt;s-exp&lt;&#x2F;code&gt;
元语言来简化这些流程. 可以像其他 module language 一样使用:
&lt;code&gt;#lang s-exp module-path&lt;&#x2F;code&gt; . 它读入后面的 s-expression 并用 &lt;em&gt;module path&lt;&#x2F;em&gt;
展开.&lt;&#x2F;p&gt;
&lt;p&gt;这些 Racket 的基础设施为我们的语言定制提供了帮手.
上面的内容如果没有完全理解也不用着急. 后文中遇到相关内容时会做详细解释.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;brainfuck-yu-fa&quot;&gt;brainfuck 语法&lt;&#x2F;h1&gt;
&lt;p&gt;之所以选择 brainfuck 作为示例, 是因为它的语法足够简单,
我们不用操心解析器的复杂度, 也能完全实现整个流程. 完整的 brainfuck
语法只使用了8种符号用来操作 brainfuck 机器:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;&#x2F;code&gt; , 向后移动指针&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;&#x2F;code&gt; , 向前移动指针&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;+&lt;&#x2F;code&gt; , 指针所指字节 + 1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;-&lt;&#x2F;code&gt; , 指针所指字节 - 1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;,&lt;&#x2F;code&gt; , 从标准输入读入一个字节并写入指针&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.&lt;&#x2F;code&gt; , 向标准输出写入指针所指的一个字节&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;[ ... ]&lt;&#x2F;code&gt; , 循环, 当运行到 &lt;code&gt;]&lt;&#x2F;code&gt; 时若指针指向的字节为0则跳出&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;brainfuck 机器由一条长度为30000 byte 的数据与一个指针构成.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;shi-xian-brainfuck-yu-yi&quot;&gt;实现 brainfuck 语义&lt;&#x2F;h1&gt;
&lt;p&gt;在这个章节我们需要实现 brainfuck 各种符号的语义. 在此之前, 我们需要实现
brainfuck 机器的定义:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-struct &lt;&#x2F;span&gt;&lt;span&gt;state (data ptr) #:mutable)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new-state&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  (state (make-vector &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30000 0&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;define-struct&lt;&#x2F;code&gt; 宏为 &lt;code&gt;state&lt;&#x2F;code&gt; 生成了默认的构造函数 &lt;code&gt;state&lt;&#x2F;code&gt;
和访问成员的函数 &lt;code&gt;state-*&lt;&#x2F;code&gt; . 我们需要修改虚拟机的状态, 所以需要添加
&lt;code&gt;#:mutable&lt;&#x2F;code&gt; 关键字, 让宏为我们生成 &lt;code&gt;set-state-*!&lt;&#x2F;code&gt; 函数.
最后我们定义了一个无参函数 &lt;code&gt;new-state&lt;&#x2F;code&gt; 用于创建 brainfuck 虚拟机.&lt;&#x2F;p&gt;
&lt;p&gt;有了虚拟机状态定义, 实现除了循环外的语义是十分简单的工作.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;increment-ptr &lt;&#x2F;span&gt;&lt;span&gt;a-state)
&lt;&#x2F;span&gt;&lt;span&gt;  (set-state-ptr! a-state (add1 (state-ptr a-state))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;decrement-ptr &lt;&#x2F;span&gt;&lt;span&gt;a-state)
&lt;&#x2F;span&gt;&lt;span&gt;  (set-state-ptr! a-state (sub1 (state-ptr a-state))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;increment-byte &lt;&#x2F;span&gt;&lt;span&gt;a-state)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;([v (state-data a-state)] [i (state-ptr a-state)])
&lt;&#x2F;span&gt;&lt;span&gt;    (vector-set! v i (add1 (vector-ref v i)))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;decrement-byte &lt;&#x2F;span&gt;&lt;span&gt;a-state)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;([v (state-data a-state)] [i (state-ptr a-state)])
&lt;&#x2F;span&gt;&lt;span&gt;    (vector-set! v i (sub1 (vector-ref v i)))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;write-byte-to-stdout &lt;&#x2F;span&gt;&lt;span&gt;a-state)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;([v (state-data a-state)] [i (state-ptr a-state)])
&lt;&#x2F;span&gt;&lt;span&gt;    (write-byte (vector-ref v i) (current-output-port))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;read-byte-from-stdin &lt;&#x2F;span&gt;&lt;span&gt;a-state)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;([v (state-data a-state)] [i (state-ptr a-state)])
&lt;&#x2F;span&gt;&lt;span&gt;    (vector-set! v i (read-byte (current-input-port)))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;current-*-port&lt;&#x2F;code&gt; 是一个 Racket 中的 parameter,
我们需要使用函数调用才能获取端口的值. Parameter 的值可以通过
&lt;code&gt;parameterize&lt;&#x2F;code&gt; 指定某个 scope 中的 parameter 值. (后面也会用到
parameter)&lt;&#x2F;p&gt;
&lt;p&gt;与其他语法符号不同, 我们需要使用宏来实现循环. 至于原因,
我们先看循环的实现:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(loop a-state body ...)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;local &lt;&#x2F;span&gt;&lt;span&gt;[(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unless &lt;&#x2F;span&gt;&lt;span&gt;(= (vector-ref (state-data a-state) (state-ptr a-state)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;              body ...
&lt;&#x2F;span&gt;&lt;span&gt;              (loop)))]
&lt;&#x2F;span&gt;&lt;span&gt;    (loop)))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当符合条件时, 执行 body 并进行一次尾递归. 如果我们将这个宏定义为函数,
含义就发生了变化: 因为 Racket 是严格求值(strict)的, 在 &amp;quot;展开&amp;quot; 函数之前,
body 的值已经计算出来了, 实际上循环的 body 只执行了一遍.&lt;&#x2F;p&gt;
&lt;p&gt;严格求值的反面就是非严格求值. 其中的典型就是 Haskel,
执行函数并不一定需要计算出参数的值, 计算是 lazy 的. 比如像下面这个函数:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskel&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskel &quot;&gt;&lt;code class=&quot;language-haskel&quot; data-lang=&quot;haskel&quot;&gt;&lt;span&gt;-- non_strict :: Num b =&amp;gt; a -&amp;gt; b
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; non_strict a = 1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; bot = bot
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; non_strict bot
&lt;&#x2F;span&gt;&lt;span&gt;1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;bot&lt;&#x2F;code&gt; 是一个无法计算的值, 但是我们仍可以计算出 &lt;code&gt;non_strict bot&lt;&#x2F;code&gt; 的值,
因为返回值实际上是与参数无关的, 如果是一门严格求值的语言,
这里已经陷入死循环了.&lt;&#x2F;p&gt;
&lt;p&gt;似乎我们已经离题了. 在完成这个章节前, 我们需要在源文件最前面加上 &lt;code&gt;#lang&lt;&#x2F;code&gt;
和导出其他模块需要的定义.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;#lang racket
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;provide &lt;&#x2F;span&gt;&lt;span&gt;(all-defined-out))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; out code begins
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;expand-level&quot;&gt;Expand level&lt;&#x2F;h1&gt;
&lt;p&gt;在这个章节我们会将 brainfuck 的 s-expression 形式转换为真正的 Racket
代码来执行. 我们在 Intro 中提到的 brainfuck 代码可以用如下的 s-exp
来表示:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(plus)(plus)(plus)(plus)(plus) (plus)(plus)(plus)(plus)(plus)
&lt;&#x2F;span&gt;&lt;span&gt;(brackets
&lt;&#x2F;span&gt;&lt;span&gt; (greater-than) (plus)(plus)(plus)(plus)(plus) (plus)(plus)
&lt;&#x2F;span&gt;&lt;span&gt; (greater-than) (plus)(plus)(plus)(plus)(plus) (plus)(plus)
&lt;&#x2F;span&gt;&lt;span&gt; (plus)(plus)(plus) (greater-than) (plus)(plus)(plus)
&lt;&#x2F;span&gt;&lt;span&gt; (greater-than) (plus) (less-than)(less-than)(less-than)
&lt;&#x2F;span&gt;&lt;span&gt; (less-than) (minus))
&lt;&#x2F;span&gt;&lt;span&gt;(greater-than) (plus)(plus) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(greater-than) (plus) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(plus)(plus)(plus)(plus)(plus) (plus)(plus) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(period) (plus)(plus)(plus) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(greater-than) (plus)(plus) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(less-than)(less-than) (plus)(plus)(plus)(plus)(plus)
&lt;&#x2F;span&gt;&lt;span&gt;(plus)(plus)(plus)(plus)(plus) (plus)(plus)(plus)(plus)(plus)
&lt;&#x2F;span&gt;&lt;span&gt;(period) (greater-than) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(plus)(plus)(plus) (period)
&lt;&#x2F;span&gt;&lt;span&gt;(minus)(minus)(minus)(minus)(minus)(minus)(period)
&lt;&#x2F;span&gt;&lt;span&gt;(minus)(minus)(minus)(minus)(minus)(minus)(minus)(minus)
&lt;&#x2F;span&gt;&lt;span&gt;(period)(greater-than) (plus) (period) (greater-than) (period)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;需要做的就是将这些节点展开为真实的代码, 直接定义宏就行了.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;current-state (make-parameter (new-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(greater-than)
&lt;&#x2F;span&gt;&lt;span&gt;                    (increment-ptr (current-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(less-than)
&lt;&#x2F;span&gt;&lt;span&gt;                    (decrement-ptr (current-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(plus)
&lt;&#x2F;span&gt;&lt;span&gt;                    (increment-byte (current-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(minus)
&lt;&#x2F;span&gt;&lt;span&gt;                    (decrement-byte (current-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(period)
&lt;&#x2F;span&gt;&lt;span&gt;                    (write-byte-to-stdout (current-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(comma)
&lt;&#x2F;span&gt;&lt;span&gt;                    (read-byte-from-stdin (current-state)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(brackets body ...)
&lt;&#x2F;span&gt;&lt;span&gt;                    (loop (current-state) body ...))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;current-state&lt;&#x2F;code&gt; 就是一个 &lt;code&gt;parameter&lt;&#x2F;code&gt;. 如果我们运行了多个
brainfuck 代码, 我们是不希望多个代码间互相干扰的. 也就是说, 每一个
brainfuck module 需要有一个自己的 state.
显然我们的实现会让所有的代码使用相同的 &lt;code&gt;current-state&lt;&#x2F;code&gt; .
为了解决这个问题, 我们可以使用前文提到的 &lt;code&gt;#%module-begin&lt;&#x2F;code&gt; 和
&lt;code&gt;parameterize&lt;&#x2F;code&gt;, 在每一个 brainfuck module 隐式插入 &lt;code&gt;parameterize&lt;&#x2F;code&gt; ,
保证每一个 module 的 state 相互隔离.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-syntax-rule &lt;&#x2F;span&gt;&lt;span&gt;(bf-module-begin body ...)
&lt;&#x2F;span&gt;&lt;span&gt;  (#%plain-module-begin
&lt;&#x2F;span&gt;&lt;span&gt;    (parameterize ([current-state (new-state)])
&lt;&#x2F;span&gt;&lt;span&gt;      body ...)))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样, 一个模块的代码被完全包裹在了 &lt;code&gt;parameterize&lt;&#x2F;code&gt; 的 scope 中,
无需再担心多个模块互相干扰了.&lt;&#x2F;p&gt;
&lt;p&gt;我们并不需要定制函数调用等等, 所以就不用管其他三个了.
不要忘了导入之前的定义和导出.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;#lang racket
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;semantics.rkt&amp;quot;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; 我们之前写的语义部分
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;provide &lt;&#x2F;span&gt;&lt;span&gt;greater-than
&lt;&#x2F;span&gt;&lt;span&gt;         less-than
&lt;&#x2F;span&gt;&lt;span&gt;         plus
&lt;&#x2F;span&gt;&lt;span&gt;         minus
&lt;&#x2F;span&gt;&lt;span&gt;         period
&lt;&#x2F;span&gt;&lt;span&gt;         comma
&lt;&#x2F;span&gt;&lt;span&gt;         brackets
&lt;&#x2F;span&gt;&lt;span&gt;         (rename-out [bf-module-begin #%module-begin]))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; our code begins
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们使用 Racket 提供的元语言 &lt;code&gt;#lang s-exp &amp;quot;language.rkt&amp;quot;&lt;&#x2F;code&gt; 并用
language.rkt 进行展开就可以运行这些 s-expressions 了.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;reader&quot;&gt;Reader&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;shi-xian-parser&quot;&gt;实现 Parser&lt;&#x2F;h2&gt;
&lt;p&gt;前面我们已经可以执行生成的 s-exp 了, 我们现在来考虑如何将 brainfuck
代码转换为 s-exp.&lt;&#x2F;p&gt;
&lt;p&gt;Racket 中使用 &lt;a href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;stx-obj.html#%28tech._identifier._syntax._object%29&quot;&gt;syntax
object&lt;&#x2F;a&gt;
来表示语法对象. 其实 syntax object 就是 s-exp ,
不过附加了对象在文件中的位置信息, 以及其他的信息. 我们可以使用
&lt;code&gt;datum-&amp;gt;syntax&lt;&#x2F;code&gt; 来将 s-exp 转换为 syntax object.&lt;&#x2F;p&gt;
&lt;p&gt;Racket 本身提供了一个递归下降 (recursive descent) 的解析器, 可以通过
&lt;code&gt;readtable&lt;&#x2F;code&gt; 进行扩展. 但是 brainfuck 不需要太多的语法解析,
所以我们自己手写一个也问题不大.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;#lang racket
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;provide &lt;&#x2F;span&gt;&lt;span&gt;parse-expr)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse-expr &lt;&#x2F;span&gt;&lt;span&gt;src in)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; Find out where we are now
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-values &lt;&#x2F;span&gt;&lt;span&gt;(line column position) (port-next-location in))
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; Read the next char
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;next-char (read-char in))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; Wrap raw s-exp as syntax object
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;decorate &lt;&#x2F;span&gt;&lt;span&gt;sexp span)
&lt;&#x2F;span&gt;&lt;span&gt;    (datum-&amp;gt;syntax &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#f&lt;&#x2F;span&gt;&lt;span&gt; sexp (list src line column position span)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond
&lt;&#x2F;span&gt;&lt;span&gt;    [(eof-object? next-char) eof]
&lt;&#x2F;span&gt;&lt;span&gt;    [else
&lt;&#x2F;span&gt;&lt;span&gt;      (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;next-char
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; Generate s-expression
&lt;&#x2F;span&gt;&lt;span&gt;        [(#\&amp;gt;) (decorate &amp;#39;(greater-than) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;        [(#\&amp;lt;) (decorate &amp;#39;(less-than) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;        [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#\+&lt;&#x2F;span&gt;&lt;span&gt;) (decorate &amp;#39;(plus) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;        [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#\-&lt;&#x2F;span&gt;&lt;span&gt;) (decorate &amp;#39;(minus) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;        [(#\,) (decorate &amp;#39;(comma) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;        [(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#\.&lt;&#x2F;span&gt;&lt;span&gt;) (decorate &amp;#39;(period) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; Recursive descent
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; Find out all s-exps in brackets
&lt;&#x2F;span&gt;&lt;span&gt;        [(#\[)
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;elements (parse-exprs src in))
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define-values &lt;&#x2F;span&gt;&lt;span&gt;(l c tail-position) (port-next-location in))
&lt;&#x2F;span&gt;&lt;span&gt;         (decorate `(brackets ,@elements)
&lt;&#x2F;span&gt;&lt;span&gt;                   (- tail-position position))]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        [else (parse-expr src in)])]))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; parse [ ... ]
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse-exprs &lt;&#x2F;span&gt;&lt;span&gt;source-name in)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define &lt;&#x2F;span&gt;&lt;span&gt;peeked-char (peek-char in))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cond
&lt;&#x2F;span&gt;&lt;span&gt;    [(eof-object? peeked-char)
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;error &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;parse-exprs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expected ], but read eof&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span&gt;    [(char=? peeked-char #\])
&lt;&#x2F;span&gt;&lt;span&gt;     (read-char in)
&lt;&#x2F;span&gt;&lt;span&gt;     empty]
&lt;&#x2F;span&gt;&lt;span&gt;    [(member peeked-char (list #\&amp;lt; #\&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#\+ #\-&lt;&#x2F;span&gt;&lt;span&gt; #\, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#\.&lt;&#x2F;span&gt;&lt;span&gt; #\[))
&lt;&#x2F;span&gt;&lt;span&gt;     (cons (parse-expr source-name in)
&lt;&#x2F;span&gt;&lt;span&gt;           (parse-exprs source-name in))]
&lt;&#x2F;span&gt;&lt;span&gt;    [else
&lt;&#x2F;span&gt;&lt;span&gt;      (read-char in)
&lt;&#x2F;span&gt;&lt;span&gt;      (parse-exprs source-name in)]))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用于解析 &lt;code&gt;[ ... ]&lt;&#x2F;code&gt; 的 &lt;code&gt;parse-exprs&lt;&#x2F;code&gt; 使用了尾递归. &lt;code&gt;cons&lt;&#x2F;code&gt;
的作用就是将当前的解析到的符号和之后尾递归解析到的符号连接在一起,
作为一个整体返回. 可以当作这样的伪代码:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;while xxx {
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 计算出当前的语法树节点
&lt;&#x2F;span&gt;&lt;span&gt;  ast.push_back(node)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;return ast
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;zai-brainfuck-zhong-jia-ru-jie-xi-qi&quot;&gt;在 brainfuck 中加入解析器&lt;&#x2F;h2&gt;
&lt;p&gt;将我们实现的 parser 作为 module language 的解析器, 然后再用之前的 expand
level 代码就可以运行了 brainfuck 代码了. 幸运的是, Racket 为我们提供了
&lt;code&gt;#lang s-exp syntax&#x2F;module-reader&lt;&#x2F;code&gt; , 我们可以在这个文件中指定用于 expand
level 的代码和使用的 &lt;code&gt;read&lt;&#x2F;code&gt; 和 &lt;code&gt;read-syntax&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;racket&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-racket &quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;span&gt;#lang s-exp syntax&#x2F;module-reader
&lt;&#x2F;span&gt;&lt;span&gt;bf&#x2F;language
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#:read my-read
&lt;&#x2F;span&gt;&lt;span&gt;#:read-syntax my-read-syntax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;..&#x2F;parser.rkt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my-read &lt;&#x2F;span&gt;&lt;span&gt;in)
&lt;&#x2F;span&gt;&lt;span&gt;  (syntax-&amp;gt;datum (my-read-syntax &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#f&lt;&#x2F;span&gt;&lt;span&gt; in)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;define&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my-read-syntax &lt;&#x2F;span&gt;&lt;span&gt;src in)
&lt;&#x2F;span&gt;&lt;span&gt;  (parse-expr src in))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第二行指出了 expand level 的模块. 因为语法限制, 这里只能使用字母, 括号,
下划线等等, 并不能使用双引号来引用文件路径,
所以我们必须安装我们的这个包, 使用
&lt;code&gt;$ raco pkg install --link path&#x2F;to&#x2F;bf&lt;&#x2F;code&gt; 安装本地包, 这里的 &lt;code&gt;language&lt;&#x2F;code&gt;
即指我们之前写的 expand 代码. 然后我们 &lt;code&gt;require&lt;&#x2F;code&gt; 这个文件,
就可以调用我们自己的parser 和 expander 来执行代码了.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;Hello world!&lt;&#x2F;h2&gt;
&lt;p&gt;为了能够在源文件开头使用 &lt;code&gt;#lang bf&lt;&#x2F;code&gt; 指定语言, 我们需要将这个文件放到
&lt;code&gt;path&#x2F;to&#x2F;bf&#x2F;reader.rkt&lt;&#x2F;code&gt; 处, 这样 Racket 就可以找到我们的语言了.
现在我们可以成功运行 *Intro 的代码了. Hello World!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;jie-yu&quot;&gt;结语&lt;&#x2F;h1&gt;
&lt;p&gt;虽然 Racket 是一门 JIT 语言, 但是我们在这里实现的 brainfuck
的效率还有很大的提升空间(如何优化可以参考 brainfudge,
本文主要的参考来源). 之前学习了 Scheme 和 Racket , 总想写点什么. 在读到
Racket Guide 第十七章后便决定写一个基于 Racket 的语言, 最后决定为
brainfuck. 参照教程磕磕碰碰写完后, 这让我再一次领略到了 Lisp 的魅力
(第一次是完全尝试用递归实现了算法题). 之后准备看看 &lt;em&gt;Hackers &amp;amp; Painters&lt;&#x2F;em&gt;
.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;can-kao&quot;&gt;参考&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;languages.html&quot;&gt;The Racket Guide :: Creating
Languages&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dyoo&#x2F;brainfudge&quot;&gt;brainfudge&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;学习 Racket 可以参考&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;index.html&quot;&gt;The Racket Guide&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;songjinghe.github.io&#x2F;TYS-zh-translation&#x2F;&quot;&gt;Teach Yourself Scheme in Fixnum Days
中译&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Org 速查手册</title>
        <published>2023-01-27T00:00:00+00:00</published>
        <updated>2023-01-27T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/org-manual/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/org-manual/</id>
        
        <content type="html">&lt;h1 id=&quot;wen-dang-jie-gou&quot;&gt;文档结构&lt;&#x2F;h1&gt;
&lt;p&gt;Org是基于Outline模式实现的.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;biao-ti&quot;&gt;标题&lt;&#x2F;h2&gt;
&lt;p&gt;标题定义了大纲树的结构, 以从行首开始的若干个星号标识.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lie-biao&quot;&gt;列表&lt;&#x2F;h2&gt;
&lt;p&gt;可以使用有序列表, 无序列表, 描述列表.&lt;&#x2F;p&gt;
&lt;p&gt;无序列表&lt;br &#x2F;&gt;
以 - , + 或 * 开头&lt;&#x2F;p&gt;
&lt;p&gt;有序列表&lt;br &#x2F;&gt;
以 1. 或 1) 开头&lt;&#x2F;p&gt;
&lt;p&gt;描述列表&lt;br &#x2F;&gt;
用::将项和描述分开&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jiao-zhu&quot;&gt;脚注&lt;&#x2F;h2&gt;
&lt;p&gt;脚注就是以脚注定义符号开头的一段话,
脚注定义符号是将脚注名称放在一个方括号里形成的, 要求放在第0列,
不能有缩进. 而引用就是在正文中将脚注名称用方括号括起来.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;The Org homepage.[fn:1]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[fn:1] The link is: http:&#x2F;&#x2F;orgmode.org
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;biao-ge&quot;&gt;表格&lt;&#x2F;h1&gt;
&lt;p&gt;任何以 | 为首个非空字符的行都会被认为是表格的一部分. | 也是列分隔符.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;| Name  | Phone | Age |
&lt;&#x2F;span&gt;&lt;span&gt;|-------+------+-----|
&lt;&#x2F;span&gt;&lt;span&gt;| Peter | 1234 | 17  |
&lt;&#x2F;span&gt;&lt;span&gt;| Anna  | 4321 | 25  |
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Phone&lt;&#x2F;th&gt;&lt;th&gt;Age&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Peter&lt;&#x2F;td&gt;&lt;td&gt;1234&lt;&#x2F;td&gt;&lt;td&gt;17&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Anna&lt;&#x2F;td&gt;&lt;td&gt;4321&lt;&#x2F;td&gt;&lt;td&gt;25&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h1 id=&quot;lian-jie&quot;&gt;链接&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;[[link][description]]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;or
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[link]]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;dai-ban-shi-xiang&quot;&gt;待办事项&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;* STATE [#PRIORITY] ITEM :TAG_A:TAG_B:...
&lt;&#x2F;span&gt;&lt;span&gt;:PROPERTIES:
&lt;&#x2F;span&gt;&lt;span&gt;:p: ...
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;:END:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当纯文本的项以 &lt;code&gt;[]&lt;&#x2F;code&gt; 开头时, 就会变成一个复选框.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;* TODO Organize party [1&#x2F;3]
&lt;&#x2F;span&gt;&lt;span&gt;- [-] call people [1&#x2F;2]
&lt;&#x2F;span&gt;&lt;span&gt;  - [ ] Peter
&lt;&#x2F;span&gt;&lt;span&gt;  - [X] Sarah
&lt;&#x2F;span&gt;&lt;span&gt;- [X] order food
&lt;&#x2F;span&gt;&lt;span&gt;- [ ] think about what music to play
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;zi-ti-yang-shi&quot;&gt;字体样式&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;*粗体*
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;斜体&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;+删除线+
&lt;&#x2F;span&gt;&lt;span&gt;_下划线_
&lt;&#x2F;span&gt;&lt;span&gt;下标： H_2 O
&lt;&#x2F;span&gt;&lt;span&gt;上标： E=mc^2
&lt;&#x2F;span&gt;&lt;span&gt;等宽字：  =git=  或者 ~git~
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;粗体&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;斜体&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;del&gt;删除线&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;u&gt;下划线&lt;&#x2F;u&gt;&lt;&#x2F;p&gt;
&lt;p&gt;等宽字： &lt;code&gt;git&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;can-kao&quot;&gt;参考&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;orgmode.org&#x2F;manuals.html&quot;&gt;Orgmode官方手册&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-orgmode&#x2F;orgmode&#x2F;blob&#x2F;master&#x2F;DOCS.md&quot;&gt;Orgmode for
Neovim&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Hello World</title>
        <published>2022-01-27T00:00:00+00:00</published>
        <updated>2022-01-27T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://refrigerator.navihx.top/posts/hello-world/" type="text/html"/>
        <id>https://refrigerator.navihx.top/posts/hello-world/</id>
        
        <content type="html">&lt;h1 id=&quot;hello-world&quot;&gt;Hello World!&lt;&#x2F;h1&gt;
&lt;p&gt;Reborn with &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&quot;&gt;Zola&lt;&#x2F;a&gt; and the power of
&lt;a href=&quot;https:&#x2F;&#x2F;orgmode.org&#x2F;&quot;&gt;org&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
